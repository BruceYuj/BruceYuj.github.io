<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BruceYJ</title>
  
  <subtitle>BruceYJ BLOG</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.bruceyj.com/"/>
  <updated>2019-05-06T07:40:25.884Z</updated>
  <id>http://www.bruceyj.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ECMAScript中的Number Type与 IEEE 754-2008</title>
    <link href="http://www.bruceyj.com/2019/05/02/2019-5-2-ECMAScript-Number-type-and-IEEE-754/"/>
    <id>http://www.bruceyj.com/2019/05/02/2019-5-2-ECMAScript-Number-type-and-IEEE-754/</id>
    <published>2019-05-02T15:13:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#div-class-tocend-div"></div></a></li><li><a href="#introduction">introduction</a><ul><li><a href="#qian-zhi-zhi-shi">前置知识</a></li></ul></li><li><a href="#ieee754-64-bit-double-precision-fu-dian-shu">IEEE754 64-bit double precision 浮点数</a><ul><li><a href="#an-quan-zheng-shu">安全整数</a></li><li><a href="#ju-ti-shi-xian-de-64-bit-precision-an-li">具体实现的64-bit precision案例</a></li><li><a href="#ecmascript2015-specification-6-1-6-number-type">ECMASCript2015 specification: 6.1.6 Number Type</a></li></ul></li><li><a href="#xia-mian-wei-shi-me-0-1-0-2-0-30000000000000004">下面为什么<code>0.1 + 0.2 = 0.30000000000000004</code>?</a><ul><li><a href="#wei-shi-me-x-0-1-neng-de-dao-0-1">为什么<code>x=0.1</code>能得到<code>0.1</code></a></li></ul></li><li><a href="#wo-men-gai-ru-he-chu-li-zhe-lei-fu-dian-wu-chai-wen-ti">我们该如何处理这类浮点误差问题</a></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --><h2><span id=""><div class="tocEnd"></div></span><a href="#" class="header-anchor">#</a></h2><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>稍微深入了解一下JavaScript浮点数的开发者都会知道浮点数的误差问题，也就是说IEEE754-2008的浮点数误差。<br>常见的案例为: <code>0.1 + 0.2 = 0.30000000000000004</code><br>无论是google一下或者baidu一下，这类文章层出不穷，但是很多都是浅尝即止，无法让我能够逻辑通顺的理解。在所有阅读的中文资料当中，我觉得较优秀的是camsong同学的<a href="https://zhuanlan.zhihu.com/p/30703042" target="_blank" rel="external">抓住数据的尾巴</a>，有些图是直接借鉴该同学的(会注明)，但是这篇文章的一个问题是，对于某些数学上的区间表示不清楚，比如究竟是开区间还是闭区间。因此，我写下了该篇文章。<br>主要阅读的资料来源: ECMAScript 2015, ECMAScript 2018, wiki, etc.</p><p>首先，给出整篇文章的思维导图：<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-mindmap.png" alt=""></p><h3><span id="qian-zhi-zhi-shi">前置知识</span><a href="#qian-zhi-zhi-shi" class="header-anchor">#</a></h3><ol><li>代数数学告诉我们实数(real number)包含有理数(rational number)和无理数:</li></ol><ul><li>有理数是一个整数a和一个正整数b的比(<code>a/b</code>),是整数和分数的集合，整数可以看成分母为1的分数，有理数的小数部分是有限的或为无限循环的数。</li><li>无理数是所有不是有理数字的实数，常见的无理数有：欧拉数e，黄金比例φ,数字π等. </li></ul><p>很明显，在后面会知道，现代计算机使用有限的bits来存储浮点数，因此只能<strong>精确的</strong>表示实数中小数部分为有限的有理数，对于其他的数学实数数字只能是近似等于而已。借用网络上的一张图表示即是：</p><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-1.png" alt=""></p><p><strong>结论1</strong>：数学中的实数是连续的直线，而计算机中浮点数是实数直线的间断的点。</p><ol><li>在1985年以前，编程语言对于浮点数的存储各自有各自的标准，而在1985年后，基本都采用IEEE754 arithmetic标准，目前IEEE754最新版本为IEEE754-2008, 而ECMAScript 2015以后Number Type遵循 double-precision 64-bit format IEEE754-2008 arithmetic. 具体的章节为 <em>6.1.6 The Number Type</em> </li></ol><p><strong>需要注意的是，任何标准的实现可能和标准本身有差别，而ECMAScript Number Type在描述Number type和IEEE754-2008在对double-precision 64-bit format的描述有稍微的不同, 具体在后面详细讲解</strong></p><ol><li>遵循IEEE-754的常见语言实现，比如 <code>C and C++</code>, <code>Common Lisp</code>, <code>Java</code>, <code>JavaScript</code>等。这类语言常见的关于小数的问题有两类：</li></ol><ul><li>数据精度丢失</li><li>大数危机(安全整数范围)</li></ul><ol><li>我们回顾一下计算机组成原理当中，关于二进制和十进制的转换,主要分为整数部分和小数部分：<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-2.png" alt="enter description here"></li></ol><h2><span id="ieee754-64-bit-double-precision-fu-dian-shu">IEEE754 64-bit double precision 浮点数</span><a href="#ieee754-64-bit-double-precision-fu-dian-shu" class="header-anchor">#</a></h2><p>首先看下浮点数的存储方式，64bits可以分为3个部分：</p><ul><li>符号位S： 第一位是正负数符号位(sign), 0表示正数，1表示负数。这也是为什么会出现<code>+0</code>和<code>-0</code>的原因。</li><li>指数位E：中间的11位存储指数(exponent），用来表示次方数</li><li>尾数位M：最后的52位是尾数(mantissa), 超出的部分采用进1舍0.</li></ul><p>采用wiki上的图表示就是:</p><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-3.png" alt="64-bit , wiki"><br>转换成数学公式为:</p><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-4.png" alt="公式, camsong"></p><ol><li><p>上述的公式很明显遵循科学计数法的规范，十进制<code>0&lt;M&lt;10</code>,二进制位<code>0&lt;M&lt;2</code>，也就是对于二进制来讲整数部分只能是1，所以为了更高的精度表示,我们在计算机中存储的时候可以舍去整数部分的1，只保留后面的小数部分。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">11.125 转换成二进制为 1101.001 转换成科学表达式  1.101001* 2^3</div></pre></td></tr></table></figure></li><li><p>我们来看指数位E，E是一个无符号整数，取值范围是<code>[0, 2047]</code>，但是我们通常用科学计数法表示数据时指数是可以为负数的，因此约定一个中间数(exponent bias)1023表示为0，因此<code>[1,1022]</code>表示指数位负，<code>[1024,2046]</code>表示为正(这里注意指数位为0和2047被用作特殊数字用途)。最后的公式变化为:<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-5.png" alt="enter description here"></p></li><li><p>下面我们用<code>0.1</code>来解释浮点误差的原因：</p></li></ol><ul><li><p><code>0.1</code>转成二进制表示为<code>0.0001100110011001100(1100循环)</code>, 转成科学计数法为<code>1.100110011001100 * 2^-4</code>,因此<code>E= -4+1023 = 1019</code>;M舍去舍去首位的1，小数点后第53位为1，遵循进1舍0，得到最后的结果为:<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-6.png" alt="enter description here"></p><p>我们将上面的二进制数字在数学上转化成十进制为:<br><code>0.100000000000000005551115123126</code>, 即出现了经典的浮点数误差.</p><ol><li>下面我们来看看M，也就是精度。53-bit significand precision转换成10进制能够保证15到17位的significant decimal digits precision（2−53 ≈ 1.11 × 10−16）， IEE754-2008对于边界情况有如下：</li></ol><ul><li>如果一个十进制有最多15个有效数字，转换成IEEE double-precision表示，然后再转换成十进制，最后的结果必须和最开始的十进制相同</li><li>如果一个IEEE 754 double-precision数字转换成一个十进制(至少17 significant digits)，然后再转换成double-precision 表示，最后的结果也必须和最开始的二进制相同。</li></ul></li></ul><p>因此，53-bit的精度转换成10进制为16个十进制数字(53log10(2) 约等于15.955).</p><h3><span id="an-quan-zheng-shu">安全整数</span><a href="#an-quan-zheng-shu" class="header-anchor">#</a></h3><p>首先，我们给出结论，ECMAScript的安全整数范围为 <strong>[-2^53, 2^53]</strong>，那么为什么呢？</p><ol><li>IEE754 64-bit无法表示2^53 + 1，因为尾数只有52位，共有2^53个选择，而2^53 + 1，转换成科学计数法 2^53 * (1+ 2^-53)，IEEE754 64-bit是没有办法表示的。这样明显是不安全的。</li></ol><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-7.png" alt="enter description here"></p><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-8.png" alt="enter description here"></p><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-9.png" alt="enter description here"></p><p>但是对于2^53 + 2，转换成科学计数法 2^54 * (1+ 2^-52)可以用IEEE754 64-bit表示。</p><ol><li>根据上面的现象，IEEE754能够表示的浮点数可以抽象为:</li></ol><ul><li><strong>[2^53, 2^54]</strong> 之间的数,IEEE754 64-bit能够表示的数都是可以被2整除的，两数之间的间隔为2.</li><li><strong>[2^54, 2^55]</strong> 之间的数的间隔为4</li><li>那么 <strong>[2^51, 2^52]</strong> 的数字与数字的间隔为0.5</li><li>数学归纳法总结一下:The spacing as a fraction of the numbers in the range from 2^n to 2^n+1 is 2^(n−52).</li></ul><h3><span id="ju-ti-shi-xian-de-64-bit-precision-an-li">具体实现的64-bit precision案例</span><a href="#ju-ti-shi-xian-de-64-bit-precision-an-li" class="header-anchor">#</a></h3><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-10.png" alt="enter description here"></p><ol><li><p>这里可以看出指数E为0和2047是有特殊含义的，E为0除了表示+0和-0，还表示subnormal numbers. E为2047除了表示<code>+Infinity</code>和<code>-Infinity</code>，还表示各种<code>NaN</code>。<code>NaN</code>的个数为<code>2^53 - 2</code>个。</p></li><li><p>引入了两个概念:subnormal double和normal double,下面的图基本能够表达两者之间的数学含义:<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-11.png" alt="enter description here"><br>在计算机系统当中，一个未增强的floating-point system只能包含normalized numbers（上图中的红色），而允许subnormal numbers（蓝色）扩展了系统的数字范围，处于系统underflow gap（下溢）和0之间。下面用案例详细解释了两者之间的区别：</p></li></ol><ul><li>在normal floating-point value当中，我们通过exponent（指数）的偏移来移除尾数(significand)的0(比如0.0123 = 1.23 * 10^-2)。而subnormal numbers在significand中使用了leading zero，什么是leading zero具体看下面。</li><li>在IEEE floating-point number当中，比如一个positive normalized number，通常可以表示为m~0~.m~1~m~2~…m~p-1~（这里~2~表示的下标，m代表一个sidnificant digit, p是精度，m~0~不为0）。对于一个subnormal number, exponent是可能表示的最小的exponent，zero是significand digit （0.m~1~m~2~…m~p-1~），也就是说所有的subnormal number都比最小的normal number更接近0. </li></ul><h3><span id="ecmascript2015-specification-6-1-6-number-type">ECMASCript2015 specification: 6.1.6 Number Type</span><a href="#ecmascript2015-specification-6-1-6-number-type" class="header-anchor">#</a></h3><p><strong>在ECMAScript规范当中，并没有直接用<code>s * 2^(e-1023) * M</code>这种表达方式，而是将M通过位移转换成整数，也就是<code>s * 2 ^ (e-1075) * M</code>. 这是需要注意的一点。</strong><br>具体规范当中总结出来以下几点：</p><ol><li>64 bit去掉一位符号位，可以表达为 <strong>2^64</strong> 个不同的值，而IEEE754中<strong>2^53 - 2</strong>个 “not-a-number”值在ECMAScript中统一表达为<code>NaN</code>，也就是说，Number type有(2^64 - 2^53 + 3)个不同的values。</li><li>两个特殊的值，为<code>Infinity</code> 和 <code>-Infinity</code>, 这里两个值的exponent转换为二进制位11个1，mantissia全为0(二进制).具体可以看上一小节的图篇案例。</li><li>根据上面两点推断出，有2^64 - 2^53个finite numbers. 一半是positive numbers，另一半是negative numbers。也就是说这类值包含有<code>positive zero</code>和<code>negative zero</code>两个0值. </li><li>也就是说，有2^64 - 2^53-2个非0的finite values，而这类值可以分为两类:<ul><li>normalized value ：共包含2^64 - 2^54个值，这类值的form是:<br> <code>s * M * 2^e</code>, s是<code>+1</code>或<code>-1</code>, m是positive integer（<code>[2^52, 2^53)</code>）,e的范围是<code>[-1074, 951]</code>，这里可以看出ECMAScript的实现没有采用exponent bias的表达方式</li><li>denormalized number: 共有<code>2^53 - 2</code>个，公式仍然是:<br><code>s * M * 2^e</code>, s是<code>+1</code>或<code>-1</code>, m是positive integer（<code>(0, 2^52)</code>）,e的值为-1074</li></ul></li><li>我们知道，实际上按照二进制转十进制计算，由于E的最大值是1023(除了特殊的两个e取值)，也就是说实际上可以表示的最大整数位<code>2^1024 - 1</code>，我们知道这超过了最大安全整数范围。对于不能用IEEE-754 64-bit表示的值采取round to nearest, ties to even 的模式，round to nearest我们理解，但是什么是ties to even呢? 举个例子:<br><code>9007199254740995</code>在IEEE754 64-bit中是无法表示的，因此会被绑定到<code>9007199254740996</code>上面去。</li></ol><h2><span id="xia-mian-wei-shi-me-0-1-0-2-0-30000000000000004">下面为什么<code>0.1 + 0.2 = 0.30000000000000004</code>?</span><a href="#xia-mian-wei-shi-me-0-1-0-2-0-30000000000000004" class="header-anchor">#</a></h2><p>我们来看计算步骤:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 0.1 和 0.2 都转化成二进制后再进行运算</div><div class="line">0.00011001100110011001100110011001100110011001100110011010 +</div><div class="line">0.0011001100110011001100110011001100110011001100110011010 =</div><div class="line">0.0100110011001100110011001100110011001100110011001100111</div><div class="line"></div><div class="line">转换为IEEE754 double point为 1.0 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 100 * 2^(-2),如果用二进制转成十进制为(0.3 + 5/(100 * 2^50)).去小数点后面17位精度为0.30000000000000004，</div><div class="line">这里取的是17位而不是16位，是IEEE754的规范中的计算结果</div></pre></td></tr></table></figure></p><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-12.png" alt="enter description here"></p><h3><span id="wei-shi-me-x-0-1-neng-de-dao-0-1">为什么<code>x=0.1</code>能得到<code>0.1</code></span><a href="#wei-shi-me-x-0-1-neng-de-dao-0-1" class="header-anchor">#</a></h3><p>在ECMAScript当中，没有使用IEEE754的exponent bias，而是把mantissa当中是整数，exponent为<code>[-1024,951]</code>，而2^53的十进制表示最多16位有效数字，也是最大表示的进度:<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-13.png" alt=""></p><h2><span id="wo-men-gai-ru-he-chu-li-zhe-lei-fu-dian-wu-chai-wen-ti">我们该如何处理这类浮点误差问题</span><a href="#wo-men-gai-ru-he-chu-li-zhe-lei-fu-dian-wu-chai-wen-ti" class="header-anchor">#</a></h2><p>首先，让我回想起在刷LeetCode题的时候，有一类问题即大数问题，当要计算的数超出了语言的上限，那时候我们是用数组来处理的。</p><p>首先引入两个方法, <code>Number.prototype.toPrecision</code>和<code>Number.prototype.toFixed</code>，两者都能够对于多余数字做凑整处理：</p><ul><li><code>toPrecision</code>：The toPrecision() method returns a string representing the Number object to the specified precision，是用来处理精度的，对于精度数学中表示从左只右第一个不为0的数字开始算起</li><li><code>toFixed</code>: 从小数点后指定位数取整。</li></ul><p>对于使用<code>toFixed</code>来做凑整处理，我们需要注意一些特殊案例:<br>比如<code>(1.005).toFixed(2)</code>返回<code>1.00</code>，因为<code>1.005实际为1.0049999999999999999</code><br>而对于浮点误差问题，我们通常分成两类解决方案，解决方案来自camsong同学：</p><ol><li>对于数据展示类<br>对于需要展示的数字使用<code>toPrecision</code>处理后，用<code>parseInt</code>转成数字再显示:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.toPrecision(precision));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>这里camsong同学采取12作为默认精度，是经验的选择，因为一般选12能处理大部分问题</p><ol><li>对于数据运算类<br>先将小数转成整数再运算:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 精确加法</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> num1Digits = (num1.toString().split(<span class="string">'.'</span>)[<span class="number">1</span>] || <span class="string">''</span>).length;</div><div class="line">  <span class="keyword">const</span> num2Digits = (num2.toString().split(<span class="string">'.'</span>)[<span class="number">1</span>] || <span class="string">''</span>).length;</div><div class="line">  <span class="keyword">const</span> baseNum = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(num1Digits, num2Digits));</div><div class="line">  <span class="keyword">return</span> (num1 * baseNum + num2 * baseNum) / baseNum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>并且该同学也提供了相关地库:<a href="https://github.com/nefe/number-precision" target="_blank" rel="external">number-precision</a></p><p>一些其他著名的库包括但不限于: Math.js, big.js等</p><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><ol><li><a href="https://link.zhihu.com/?target=http%3A//www.binaryconvert.com/convert_double.html" target="_blank" rel="external">IEEE754 double 可视化</a></li><li><a href="https://zhuanlan.zhihu.com/p/30703042" target="_blank" rel="external">抓住数据的小尾巴 - JS浮点数陷阱及解法</a></li><li><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" target="_blank" rel="external">double-precision floating-point format</a></li><li><a href="https://en.wikipedia.org/wiki/Denormal_number" target="_blank" rel="external">denormal number</a></li><li><a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" target="_blank" rel="external">floating point arithemtic</a></li><li><a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" target="_blank" rel="external">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></li><li><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types-number-type" target="_blank" rel="external">ECMAScript Number Type</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#div-class-tocend-div&quot;&gt;&lt;/div&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="ECMAScript" scheme="http://www.bruceyj.com/categories/ECMAScript/"/>
    
    
      <category term="ECMAScript" scheme="http://www.bruceyj.com/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>算法之trie tree</title>
    <link href="http://www.bruceyj.com/2019/03/25/2019-3-15-trie-tree/"/>
    <id>http://www.bruceyj.com/2019/03/25/2019-3-15-trie-tree/</id>
    <published>2019-03-25T15:13:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#introduction">introduction</a></li><li><a href="#trie-tree">Trie tree</a><ul><li><a href="#ji-ben-cao-zuo">基本操作</a></li><li><a href="#shi-ji-ying-yong">实际应用</a></li></ul></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --></div><hr><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>最近在做ASTR，而algorithm是该项目的task 1. 所以开始重新刷LeetCode题。相比其他ACM题库而言，LeetCode的难度属于初、中级，更加的偏向于职场，而弱化了一些高级数学相关的东西。</p><p>这段话是我对于刷LeetCode的一些看法。很多人觉得算法对于实际工作过程中的用途不大，有点类似于“面试造火箭，工作拧螺丝”。但是真的用途不大吗？我觉得并非如此，如果你能够发现里面的数学之美的话。其一，一个优秀的算法可以极大的提高你的程序运行效率，尤其在某些极端情况下面；其二，学习了这些算法，可以极大的提高我们的逻辑思维；其三，这对于面试还是有很多好处的。</p><p>我做LeetCode的方法是：</p><ol><li>选取某一到特定的题目（一般是净点赞多的优先）</li><li>做题，并研究其抽象出来的原理</li><li>举一反三运用于这一类题</li></ol><p><strong>Note</strong>： 特别强调，刷题不是目的，会做某一到具体的题更不是完成结果。学会每道题背后的原理，并能够理解、完成所有的这一类问题，以及将其运用于自己的工作当中，这才是我们真正需要达到的目标。</p><p>举个例子：</p><ol><li>选取题目leetcode 5:  Longest Palindromic Substring</li><li>由该题目联想到经典的两类问题： longest common substring problem 和 longest common subsequence problem。然后，联系到longest common substring problem的一般解决思路，generalized suffix tree，在细化到 trie tree。</li><li>搜索相关的问题，并解决。</li></ol><h2><span id="trie-tree">Trie tree</span><a href="#trie-tree" class="header-anchor">#</a></h2><p>首先<em>Trie</em> 来自于单词<em>retrieval</em>, 通常发音为 /ˈtraɪ/ (as “try”).</p><blockquote><p>In computer science, a trie, also called digital tree, radix tree or prefix tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. </p></blockquote><p>Trie tree，又被称为字典树或前缀树。从名字我们可以推断出其可以被用来查找字符串。</p><p>我们先来看一个例子：</p><ol><li>给定一个字符串集合<code>cat, cash, app, apple , aply, ok</code>，来构建一颗字典树， 如下图：</li></ol><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-1.jpg" alt="Trie tree 1"></p><p>由此我们引出字典树的特点：</p><ol><li>Trie tree用边来表示字母</li><li>有相同前缀的单词公用前缀节点。那么我们可以知道，在单词只包含小写字母的情况下，我们可以知道每个节点最多有26个子节点</li><li>整棵树的根节点是空的</li><li>每个单词结束的时候用特殊字符表示(比如上图的$)，在代码中可以单独建立一个bool字段来表示是否是单词结束处</li></ol><h3><span id="ji-ben-cao-zuo">基本操作</span><a href="#ji-ben-cao-zuo" class="header-anchor">#</a></h3><p>最简单的两个操作为: <strong>insert</strong> 和 <strong>search</strong></p><ol><li>insert: 插入一个新单词<blockquote><p>从图中可以直观看出来，从左到右扫描新单词，如果字母在相应根节点下没有出现过，就插入这个字母；否则沿着字典树往下走，看单词的下一个字母。</p></blockquote></li></ol><p>问题1： 字母往哪个位置插？<br>有两种编码方式。第一种可以按照输入顺序对其进行编码，这里相同字母的编码可能不同：<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-2.jpg" alt="trie tree 2"></p><p>第二种编码方式:<br>因为每个节点最多26个子节点，我可以可以按他们的字典序0-25编号，这里相同字母的编码相同<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-3.jpg" alt="enter description here"></p><p>通常来讲，我们来实现这个数据结构会有两种方式：</p><ul><li>数组模拟</li><li>类的形式</li></ul><p>通常，虽然第二种方式更加的浪费空间，但是我会更加的喜欢用第二种方式。比如在处理下面这几个问题时更加方便：</p><ul><li>查询某个单词是否存在字典树中。我们只需要在节点中添加属性表示即可。</li><li>查询某个前缀出现的次数。我们仍然只需要在节点中添加属性即可。</li></ul><p>因此，我们来看实际的代码(javascript版):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">var</span> TrieNode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.isEnd = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">this</span>.links = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>);</div><div class="line">&#125;</div><div class="line">TrieNode.prototype.containsKey = <span class="function"><span class="keyword">function</span>(<span class="params">ch</span>) </span>&#123; <span class="comment">// 当前节点的子节点中是否包含该字符</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.links[ch.charCodeAt(<span class="number">0</span>) - <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>)] !== <span class="literal">undefined</span>; </div><div class="line">&#125;</div><div class="line">TrieNode.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">ch</span>) </span>&#123; <span class="comment">// 获取当前节点相关字符的子节点</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.links[ch.charCodeAt(<span class="number">0</span>) - <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>)];</div><div class="line">&#125;</div><div class="line">TrieNode.prototype.put = <span class="function"><span class="keyword">function</span>(<span class="params">ch, node</span>) </span>&#123; <span class="comment">// 插入当前相关字符的子节点</span></div><div class="line">    <span class="keyword">this</span>.links[ch.charCodeAt(<span class="number">0</span>) - <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>)] = node;</div><div class="line">&#125;</div><div class="line">TrieNode.prototype.setEnd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 设置当前节点是否为单词结尾</span></div><div class="line">    <span class="keyword">this</span>.isEnd =<span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Initialize your data structure here.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> Trie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Inserts a word into the trie. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; word</span></div><div class="line"><span class="comment"> * @return &#123;void&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> currentChar = word[i];</div><div class="line">        <span class="keyword">if</span>(!node.containsKey(currentChar)) &#123;</div><div class="line">            node.put(currentChar, <span class="keyword">new</span> TrieNode());</div><div class="line">        &#125;</div><div class="line">        node = node.get(currentChar);</div><div class="line">    &#125;</div><div class="line">    node.setEnd();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns if the word is in the trie. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; word</span></div><div class="line"><span class="comment"> * @return &#123;boolean&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> currentChar = word[i];</div><div class="line">        <span class="keyword">if</span>(node.containsKey(currentChar)) &#123;</div><div class="line">            node = node.get(currentChar);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node.isEnd();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns if there is any word in the trie that starts with the given prefix. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; prefix</span></div><div class="line"><span class="comment"> * @return &#123;boolean&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> currentChar = word[i];</div><div class="line">        <span class="keyword">if</span>(node.containsKey(currentChar)) &#123;</div><div class="line">            node = node.get(currentChar);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> */</span></div><div class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> Trie();</div><div class="line">  <span class="keyword">let</span> words = [<span class="string">"Trie"</span>,<span class="string">"insert"</span>,<span class="string">"search"</span>,<span class="string">"search"</span>,<span class="string">"startsWith"</span>,<span class="string">"insert"</span>,<span class="string">"search"</span>]</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; words.length; i++ ) &#123;</div><div class="line">    obj.insert(words[i]);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>很明显，上面的写法比较偏向于工程化，比较完整类型的，上面的代码可以更加的优化,我们用对象来模拟：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Trie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">this</span>.root = &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Inserts a word into the trie. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; word</span></div><div class="line"><span class="comment"> * @return &#123;void&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> word) &#123;</div><div class="line">      <span class="keyword">if</span> (!(ch <span class="keyword">in</span> node)) node[ch] = &#123;&#125;</div><div class="line">      node = node[ch]</div><div class="line">    &#125;</div><div class="line">    node[<span class="string">'$'</span>] = <span class="literal">true</span> <span class="comment">// 表示单词结束位置</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns if the word is in the trie. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; word</span></div><div class="line"><span class="comment"> * @return &#123;boolean&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ch <span class="keyword">of</span> word) &#123;</div><div class="line">      <span class="keyword">if</span>(ch <span class="keyword">in</span> node) node = node[ch]</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node[<span class="string">'$'</span>] === <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns if there is any word in the trie that starts with the given prefix. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; prefix</span></div><div class="line"><span class="comment"> * @return &#123;boolean&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ch <span class="keyword">of</span> prefix) &#123;</div><div class="line">      <span class="keyword">if</span>(ch <span class="keyword">in</span> node) node = node[ch]</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>我们来看看两段代码的运行效率：<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-result.png" alt="execute result"></p><h3><span id="shi-ji-ying-yong">实际应用</span><a href="#shi-ji-ying-yong" class="header-anchor">#</a></h3><p>我们下面来看看实际开发中trie tree的运用：</p><ol><li><p>autocomplete<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-208_GoogleSuggest.png" alt="enter description here"></p></li><li><p>spell checker<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-208_SpellCheck.png" alt="enter description here"></p></li><li><p>IP routing(longest prefix matching)<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-208_IPRouting.gif" alt="enter description here"></p></li><li><p>T9 predictive text<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-208_T9.jpg" alt="enter description here"></p></li></ol><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><ol><li><a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="external">Trie, wiki</a></li><li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/submissions/" target="_blank" rel="external">leetcode 208. Implement Trie (Prefix Tree)</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#trie-tree&quot;&gt;Trie tree&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.bruceyj.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://www.bruceyj.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>深入CSS基础之box model</title>
    <link href="http://www.bruceyj.com/2019/02/19/2019-2-19-deep-into-css-box-model/"/>
    <id>http://www.bruceyj.com/2019/02/19/2019-2-19-deep-into-css-box-model/</id>
    <published>2019-02-19T15:13:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#yue-du-zhu-yi-shi-xiang">阅读注意事项</a></li><li><a href="#introduction">introduction</a></li><li><a href="#shi-me-shi-box-model-he-mo-xing">什么是box model(盒模型)</a><ul><li><a href="#box-dimension-he-chi-cun">box dimension(盒尺寸)</a></li><li><a href="#shuang-xiang-huan-jing-bidirectional-context-zhong-inline-level-yuan-su-de-he-mo-xing">双向环境(bidirectional context)中inline-level 元素的盒模型</a></li></ul></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --></div><h2><span id="yue-du-zhu-yi-shi-xiang">阅读注意事项</span><a href="#yue-du-zhu-yi-shi-xiang" class="header-anchor">#</a></h2><ol><li>本篇文章的依赖主要是<strong>CSS2.1 specification 8</strong> 和 <strong>CSS Box Model Module Level 3</strong>。</li><li>本篇整体比较细节和理论，可能会看起来枯燥，我尽量讲的逻辑简单些。个人认为有时候阅读枯燥的理论文章是有必要的。</li><li>写这篇的文章主要目的在于完善自己的知识体系。因此希望大家能够多多指出文章中不恰当之地方。</li></ol><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>box model应该是CSS当中最核心的概念之一了，本篇主要讲述CSS当中的box model(盒模型)。</p><p>在看本篇内容之前，可以先自己回答下面几个问题：</p><ol><li>什么是box model？ box model 包含了哪些内容？ 它的作用是什么？ 它出现在浏览器处理文档的哪一个步骤？ 后续步骤是什么？</li><li>collapse margin的细节是什么？</li></ol><h2><span id="shi-me-shi-box-model-he-mo-xing">什么是box model(盒模型)</span><a href="#shi-me-shi-box-model-he-mo-xing" class="header-anchor">#</a></h2><p><a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/box.html" target="_blank" rel="external">CSS2.1 specification 8.box model</a> 第一句话就很好的描述了它的定义：</p><blockquote><p>The CSS box model describes the rectangular boxes that are generated for elements in the document tree and laid out according to the visual formatting model.</p></blockquote><p>从这句话中我们可以得出来<code>box model</code>是什么：<br><code>box model</code>是用来描述DOM树中元素生成的矩形盒子的，并且UAs会根据 <code>visual formatting model</code> 来布局这些盒子。</p><h3><span id="box-dimension-he-chi-cun">box dimension(盒尺寸)</span><a href="#box-dimension-he-chi-cun" class="header-anchor">#</a></h3><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190219-deep-into-css-box-model-box.png" alt="typical box"></p><p>这一小节是用来描述具体的矩形盒子的，每个盒子会有4块区域：</p><ul><li>content area</li><li>padding area</li><li>border area</li><li>margin area<br>每块区域的尺寸由各自相关的属性决定。另外 <code>padding</code>, <code>border</code>, <code>margin</code> 可以被分割成<code>top, bottom, left, right</code> 四个小区域，并由具体的属性来定义。</li></ul><p>下面我们来引入新的名词(为了后面的内容)，<strong><code>edge</code>:  每个盒子的周长被称为<code>edge</code>，即边界</strong>。相应的，我们可以知道每个box都会有四个<code>edge</code>.</p><ul><li>content edge or inner edge: content area 的尺寸默认由元素的<code>width</code> 和 <code>height</code> 两个属性，元素的内容以及它的containing block决定</li><li>padding edge： padding edge定义了元素的padding box（包含content 和 padding area）</li><li>border edge: border edge定义了元素的border box（包含content，padding 和 border area）</li><li>margin edge or outer edge:如果 margin的width为0，那么margin area和padding area 一样</li></ul><p><strong>Note</strong>： 一个box的content area， padding area 和 border area的 background样式由该元素的 <code>background</code>属性决定。也就是说<code>background</code> 默认会一直延伸到 border area，而 margin总是透明的。在CSS3中，我们可以使用background新属性来修改默认情况。</p><blockquote><p>CSS Box model 3 新增加一段：<br>When a box fragments—is broken, as across lines or across pages, into separate box fragments—each of its boxes (content box, padding box, border box, margin box) also fragments. How the content/padding/border/margin areas react to fragmentation is specified in [css-break-3] and controlled by the box-decoration-break property.</p></blockquote><p>这一段主要讲的是当一个盒子跨行或者跨页时会被分割成多个box片段，那么对于该盒子的content，padding，border，margin在不同的box 片段中该如何表现？这些内容定义在<a href="https://www.w3.org/TR/css-break-3/" target="_blank" rel="external">css-break-3</a>中，并且可以使用<code>box-decoration-break</code>来控制。<br>另外其实在CSS2.1也有描述这样的场景，在8.6中描述了inline box跨行时盒模型该如何表现。</p><h4><span id="margin-shu-xing-margin-top-margin-bottom-margin-left-margin-right-he-margin">margin属性: <code>margin-top</code>, <code>margin-bottom</code>, <code>margin-left</code>, <code>margin-right</code> 和 <code>margin</code></span><a href="#margin-shu-xing-margin-top-margin-bottom-margin-left-margin-right-he-margin" class="header-anchor">#</a></h4><p>这些属性都是初学时就已经用的很熟的。因此，这里只强调几个注意事项：<br>先看属性的定义</p><blockquote><p><strong>‘margin-top’, ‘margin-bottom’, ‘margin-left’, ‘margin-right’</strong><br>Value:      <code>&lt;margin-width&gt;</code> | inherit<br>Initial:      0<br>Applies to:      all elements except elements with table display types other than table-caption, table and inline-table<br>Inherited:      no<br>Percentages:      refer to width of containing block<br>Media:      visual<br>Computed value:      the percentage as specified or the absolute length</p></blockquote><ol><li><code>value</code>可以是 <code>&lt;margin-width&gt;</code> ，包含3种具体的取值：<ul><li><code>&lt;length&gt;</code>: 指定固定的宽度，比如<code>3px</code>, <code>1em</code>等</li><li><code>&lt;percentage&gt;</code>: 百分比取值在由<code>computed value</code>转换成<code>used value</code>的时候计算，基数是<code>generated box&#39;s containing block</code>的<code>width</code>(也就是该元素的包含块的width). 而如果containing block的width会依赖该元素，那么具体表现在CSS 2.1中未定义的。</li><li>auto， 后面具体讲</li></ul></li><li><code>margin-top</code> 和 <code>margin-bottom</code> 对于 <code>non-replaced inline elements</code>不起作用。</li><li>在CSS3当中，上面这几个属性被称为physical margin属性。并且介绍了相对应的logical margin属性,比如<code>margin-block-start</code>,<code>margin-block-end</code>(这些属性跟文档的<code>writing mode</code>相关)。（logical margin和physical margin控制的是同样的margin区域，只是不同的表现形式而已。CSS3加入这个特性是因为不同国家的文档排列形式是不一样的，比如阿拉伯语就是从右往左写的）</li></ol><p><strong>Note</strong>: CSS3中添加的<code>margin-trim</code>属性由于目前没有任何浏览器支持，这里不做介绍(当前时间为<strong>2019年2月</strong>)。</p><h4><span id="collapsing-margins">collapsing margins</span><a href="#collapsing-margins" class="header-anchor">#</a></h4><p>在CSS当中，2个或多个盒子相邻的垂直方向margins会合并成一个margin，这种合并被我们称为<code>collapse</code>（塌陷），而合并后的margin被叫做<code>collapse margin</code>.<br>首先，我们先强调一些margin不会合并的例外情况：</p><ol><li>水平方向上的margin不会collapse</li><li>对于相邻的垂直方向上的margin不会塌陷有两种情况：<ul><li>root元素盒子的 margin不会产生塌陷(在HTML当中就是 html元素)</li><li>如果一个带有clearance(间隙，指的是<code>clear</code>属性导致元素位置移动产生的间隙)的元素的top margin和 bottom margin 存在相邻的margin，该元素的相关margin会和紧挨着的兄弟元素的相邻外边距合并，但合并后的外边距不会再和父级块的下外边距合并</li></ul></li></ol><p>那么，如何判断两个盒子的margin是相邻的(adjoining)呢? 需要同时满足下面那几个条件：</p><ul><li>两个盒子都属于in-flow(流内) <code>block-level boxes</code>，并且处于同一个<code>block formatting model</code>。</li><li>没有 <code>line box</code>, <code>clearance</code>, <code>padding</code>, <code>border</code>将它们间隔开（这里高度为0的<code>line box</code> 会被忽略)。</li><li>都属于垂直相邻的盒边界，也就是满足下面的其中一种情况：<ul><li>盒子的上外边距和其第一个 <code>in-flow</code> 孩子节点的上外边距</li><li>盒子的下外边距与其下一个紧挨着的<code>in-flow</code>中的兄弟节点的上外边距</li><li>盒子的下外边距（并且该盒子的height computed value为auto）与其最后一个<code>in-flow</code>孩子节点的下外边距</li><li>盒子的上外边距和下外边距，满足条件是：该盒子没有建立新的<code>block formatting model</code>，<code>min-height</code>为0，height的computed value为<code>0</code>或者<code>auto</code>，没有<code>in-flow</code> 孩子节点。</li></ul></li></ul><p><strong>另外需要注意的是折叠外边距也能够与另一个外边距相邻，只需要其外边距的任意一部分与另一个外边距相邻就算。</strong></p><p><strong>Note</strong>：由上面的collapse margin 的定义我们可以得出以下的推论：</p><ul><li>相邻外边距可以由不具备兄弟或祖先关系的元素之间生成</li><li><code>floated box</code>的margin和任何其他盒子的margin都不会合并（包括它流内的孩子节点）- <strong>因为 <code>float box</code>不是流内的。</strong> </li><li>绝对定位的盒子的margin和任何其他盒子的margin都不会合并（包括它流内的孩子节点） - <strong>同样是因为绝对定位的盒子是流外的。</strong></li><li>建立新的<code>block formatting context</code>的元素的margin不会与它的流内孩子节点的margin合并（比如floated box）</li><li><code>inline-block</code>盒子的margin不会与其他盒子的margin合并（包括它的流内孩子节点）- <strong>创建了新的<code>block formatting model</code>并且不是<code>block-level box</code>.</strong></li><li><code>in-flow block-level box</code>的下外边距会与相邻的<code>in-flow block-level</code>兄弟节点的上外边距合并，除非该兄弟节点存在<code>clearance</code></li><li><code>in-flow block element</code>的上外边距会与它的第一个流内孩子节点（该孩子节点是<code>block-level</code>盒子）的上外边距合并，这里需要该元素不存在<code>top border</code>，不存在<code>top padding</code>，并且孩子节点也没有<code>clearance</code></li><li>一个<code>height</code>为<code>auto</code>并且<code>min-height</code>为<code>0</code>的<code>in-flow block-level box</code>的<code>bottom margin</code>会与它的最后一个<code>流内block-level</code>的孩子节点的<code>bottom margin</code>合并，条件是该盒子没有<code>bottom padding</code>，<code>bottom border</code>并且其孩子节点的<code>bottom margin</code>没有与具有clearance的top margin合并</li><li>盒子自身的外边距也会合并，条件是<code>min-height</code>为<code>0</code>, 既没有上下边框，也没有上下内边距，height为0或者auto，且不包含line box（并且所有流内孩子的外边距都会合并）</li></ul><p><strong>那么合并后的margin该如何取值呢？</strong></p><ul><li>当两个或者更多的margin合并时，collapsed margin的宽度为被合并的所有外边距中的最大值</li><li>如果存在负margin，那么就从正相邻margin中的最大值减去负相邻margin中绝对值最大的值</li><li>如果没有正margin，就用0减去相邻margin中绝对值最大的值</li></ul><p><strong>下面我们讨论最后一种特殊情况：</strong><br>如果一个盒子的上下外边距相邻，那么有可能外边距合并会穿透该盒子。在这种情况下，该元素的位置取决于合并margin的其他元素之间的关系：</p><ul><li>如果该元素的margins和它父元素的top margin合并，那么该盒子的top border edge和它父元素的top border edge一样</li><li>否则的话，要么该元素的父元素没有参与margin collapse，要么只有该父元素的bottom margin参与。那么该元素的上边框edge和该元素bottom border非0时相同。 </li></ul><p><strong>需要注意的是，被折叠外边距穿过的元素的位置不影响其他外边距正要被合并的元素的位置，其上边框边界的位置仅仅是用于布局这些元素的后代元素。</strong></p><h4><span id="padding-shu-xing-padding-top-padding-right-padding-bottom-padding-left-he-padding">padding属性： <code>padding-top</code>, <code>padding-right</code>, <code>padding-bottom</code>, <code>padding-left</code> 和 <code>padding</code></span><a href="#padding-shu-xing-padding-top-padding-right-padding-bottom-padding-left-he-padding" class="header-anchor">#</a></h4><p>padding属性定义了盒子的内边距区域的宽度。</p><blockquote><p>‘padding-top’, ‘padding-right’, ‘padding-bottom’, ‘padding-left’<br>Value:      <code>&lt;padding-width&gt;</code> | inherit<br>Initial:      0<br>Applies to:      除table-row-group，table-header-group，table-footer-group，table-row，table-column-group和table-column外的所有元素<br>Inherited:      no<br>Percentages:      参照包含块的宽度<br>Media:      visual<br>Computed value:      指定的百分比或者绝对长度</p></blockquote><p>padding属性和margin属性主要由下面几个不同：</p><ol><li>padding的取值没有<code>auto</code></li><li>padding值不可以为负</li><li>适用的元素范围不一样</li></ol><p><strong>和margin一样的是，百分比的基数是<code>generated box&#39;s containing block</code>的<code>width</code>(也就是该元素的包含块的width)</strong>.</p><p><strong>note</strong>：这里的<code>padding-top</code>等4个属性仍然是physical 属性。在CSS3当中添加了logical padding - <code>padding-block-start</code>等。</p><h4><span id="border-shu-xing">border属性</span><a href="#border-shu-xing" class="header-anchor">#</a></h4><blockquote><p>‘border-top-width’, ‘border-right-width’, ‘border-bottom-width’, ‘border-left-width’<br>Value:      <code>&lt;border-width&gt;</code> | inherit<br>Initial:      medium<br>Applies to:      所有元素<br>Inherited:      no<br>Percentages:      N/A<br>Media:      visual<br>Computed value:      绝对长度，或者’0’，如果border style为’none’或者’hidden’的话</p></blockquote><p>对于<code>border-width</code>需要注意：</p><ol><li><code>&lt;border-width&gt;</code>只有关键字和<code>&lt;length&gt;</code>这两种选择，关键字是<code>thin</code>, <code>medium</code>, <code>thick</code>，大小依次变大，具体大小由用户代理决定</li><li>边框宽度不能为负</li></ol><blockquote><p>‘border-top-color’, ‘border-right-color’, ‘border-bottom-color’, ‘border-left-color’<br>Value:      <code>&lt;color&gt;</code> | transparent | inherit<br>Initial:      ‘color’属性的值<br>Applies to:      所有元素<br>Inherited:      no<br>Percentages:      N/A<br>Media:      visual<br>Computed value:      从’color’属性取值的话，取’color’的计算值，否则，就按指定值</p></blockquote><p><strong>这里需要注意的是： <code>border-color</code> 的初始值是 <code>color</code> 属性的值，我们有些时候可以利用这个特性来实现一些特殊的要求</strong>。</p><h3><span id="shuang-xiang-huan-jing-bidirectional-context-zhong-inline-level-yuan-su-de-he-mo-xing">双向环境(bidirectional context)中inline-level 元素的盒模型</span><a href="#shuang-xiang-huan-jing-bidirectional-context-zhong-inline-level-yuan-su-de-he-mo-xing" class="header-anchor">#</a></h3><p>对于每一个line box， UAs必须为每一个元素产生的inline box渲染margin，border，padding以visual order的方式（而非logical order）<br>主要分为两种情况：</p><ul><li><code>direction: ltr</code> : 元素出现的第一个line box的最左端生成的盒子具有左外边距，左边框，左内边距，并且元素出现的最后一个line box最右端生成的盒子具有右内边距，有边框，右外边距</li><li><code>direction: rtl</code>：元素出现的第一个line box的最右端生成的盒子具有右内边距，有边框，右外边距，并且元素出现的最后一个line box的最左端生成的盒子具有左外边距，左边框，左内边距</li></ul><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><ol><li><a href="https://www.w3.org/TR/css-box-3/" target="_blank" rel="external">CSS Box Model Module Level 3</a></li><li><a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/box.html#box-model" target="_blank" rel="external">CSS2.1 box model</a></li><li><a href="https://www.w3.org/TR/css-display-3/" target="_blank" rel="external">CSS Display Module Level 3</a></li><li><a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="external">CSS Flexible Box Layout Module Level 1</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#yue-du-zhu-yi-shi-xiang&quot;&gt;阅读注意事项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;/li
      
    
    </summary>
    
      <category term="CSS" scheme="http://www.bruceyj.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.bruceyj.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>深入CSS之属性赋值</title>
    <link href="http://www.bruceyj.com/2019/02/13/2019-2-13-deep-into-css-assign-property-values/"/>
    <id>http://www.bruceyj.com/2019/02/13/2019-2-13-deep-into-css-assign-property-values/</id>
    <published>2019-02-13T19:13:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#yue-du-zhu-yi-shi-xiang">阅读注意事项</a></li><li><a href="#introduction">introduction</a></li><li><a href="#shu-xing-fu-zhi">属性赋值</a><ul><li><a href="#specified-values">Specified Values</a></li><li><a href="#computed-values">Computed Values</a></li><li><a href="#used-values">Used Values</a></li><li><a href="#actual-values">Actual Values</a></li></ul></li><li><a href="#ji-cheng">继承</a><ul><li><a href="#ceng-die-zhong-de-inherit-zhi">层叠中的 <code>inherit</code> 值</a></li></ul></li><li><a href="#the-cascade-ceng-die">The Cascade(层叠)</a><ul><li><a href="#cascading-order-ceng-die-shun-xu">cascading order(层叠顺序)</a></li><li><a href="#important-gui-ze"><code>!important</code> 规则</a></li><li><a href="#ji-suan-xuan-ze-qi-de-specificity">计算选择器的 specificity</a></li></ul></li><li><a href="#zong-jie">总结</a></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --></div><h2><span id="yue-du-zhu-yi-shi-xiang">阅读注意事项</span><a href="#yue-du-zhu-yi-shi-xiang" class="header-anchor">#</a></h2><ol><li>本篇文章的依赖主要是<strong>CSS specification</strong>。</li><li>本篇整体比较细节和理论，可能会看起来枯燥，我尽量讲的逻辑简单些。个人认为有时候阅读枯燥的理论文章是有必要的。</li><li>写这篇的文章主要目的在于完善自己的知识体系。因此希望大家能够多多指出文章中不恰当之地方。</li></ol><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>我们在前端开发中写CSS时，如果观察仔细的话，很多时候浏览器渲染出来的元素的属性值和我们在CSS代码中指定的有差异。尽管这些差异可能对于人类视觉的感官没有什么差别，但是作为一个开发者，还是有必要了解这些差异的源头的。</p><p><strong>那么，导致属性值差异的原因是什么呢？换句话说，浏览器内部是如何来决定最后渲染的属性值的？</strong><br>让我们一同来畅游<a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html#computed-value" target="_blank" rel="external">CSS specification</a>。</p><p>首先，提出本篇文章想要解决的几个问题：</p><ol><li><em>user agent</em> 内部是如何得出最终的属性值的？</li><li><em>specified value</em>, <em>computed value</em>, <em>used value</em>, <em>actual value</em> 这几个值究竟代表着什么？</li><li>子元素属性对父元素的继承的细节是怎样的？</li><li><em>user agent</em> 究竟是如何决定样式表规则的优先级的？</li></ol><h2><span id="shu-xing-fu-zhi">属性赋值</span><a href="#shu-xing-fu-zhi" class="header-anchor">#</a></h2><p>我们知道， 在 <em>user agent</em> 解析完文档并生成DOM树后， 它需要给DOM树中的每一个元素的所有属性进行赋值。</p><p>属性赋值计算的具体的过程主要分为4个步骤：</p><ol><li><strong>specified value</strong>:  根据指定得到 <em>specified value</em></li><li><strong>computed value</strong>: 然后 <em>specified value</em> 被解析成可以用于继承的值，也就是 <em>computed value</em>. </li><li><strong>used value</strong>: 如果有必要的话，在这一阶段将 <em>computed value</em> 转成绝对值，也就是 <em>used value</em>.</li><li><strong>actual value</strong>: 最后根据本地环境的限制， <em>used value</em> 会被转换成 <em>actual value</em>.</li></ol><p>下面，我们详细的理解每一个计算步骤。</p><h3><span id="specified-values">Specified Values</span><a href="#specified-values" class="header-anchor">#</a></h3><p>对于计算的第一步， <em>user agent</em> 会给每一个元素的每个属性都赋予一个 <em>specified value</em> . 那么这个 <em>specified value</em> 从何而来呢？ 我们来看看规范给出的机制：</p><ol><li>如果 <strong>cascade(层叠，详细解释看cascade小节)</strong> 可以产生一个值，那么 <em>specified value</em> 就等于这个值。</li><li>否则，如果该属性是可以继承的并且该元素不是DOM树的根元素，那么 <em>specified value</em>就等于父元素的 <em>computed value</em> .</li><li>否则，使用该属性的 <em>initial value</em>. 而 <em>initial value</em> 来自于规范中属性的定义。</li></ol><p>规范中属性的定义如下：</p><blockquote><p><strong>width</strong><br>Value:      <code>&lt;length&gt; | &lt;percentage&gt; | auto | inherit</code><br>Initial:      auto<br>Applies to:      all elements but non-replaced inline elements, table rows, and row groups<br>Inherited:      no<br>Percentages:      refer to width of containing block<br>Media:      visual<br>Computed value:      the percentage or ‘auto’ as specified or the absolute length</p></blockquote><h3><span id="computed-values">Computed Values</span><a href="#computed-values" class="header-anchor">#</a></h3><ol><li><p>对于计算的第二步，<em>specified values</em> 通过层叠被转换成 <em>computed values</em>。也就是说，计算 <em>computed values</em> 时不需要 <em>user agent</em> 去渲染文档。<strong>举个例子， 在css代码中使用 <code>em</code> 和 <code>ex</code> 单位的资源在这个阶段可以被计算为 <code>pixel</code>或者绝对长度。</strong></p></li><li><p>如果<em>user agent</em> 无法将 <em>specified values</em> 转换为 绝对值的话，那么<em>computed values</em> 就直接使用 <em>specified values</em>.</p></li></ol><p><strong>注意</strong>：一个属性的<em>computed value</em>由规范中属性定义的 <em>computed value</em>一行决定(比如上一小节<code>width</code>属性定义中的<em>computed value</em> 一行)。<br>另外，即使属性不适用（于当前元素），其<em>computed value</em> 也存在，具体定义在规范属性定义中的<code>Applies To</code>行。然而，有些属性可能根据属性是否适用于该元素来定义元素属性的<em>computed value</em></p><h3><span id="used-values">Used Values</span><a href="#used-values" class="header-anchor">#</a></h3><p>我们从上面知道，<em>user agent</em> 在计算 <em>computed values</em> 时会尽可能的不格式化文档。但是，有些时候，某些属性值只能在布局完成时确定。<strong>举个简单例子，如果一个元素的 <code>width: 50%</code>, 而具体的 width计算需要获得 containing block的width。</strong></p><p>而在计算的第三步，<em>used value</em>  就是将 <em>computed value</em> 和 <em>相关的依赖</em> 结合来得到一个绝对值（如果本身 <em>computed value</em> 本身没有其他依赖，已经是绝对值，那么 <em>used value</em> 就等于 <em>computed value</em>）。</p><h3><span id="actual-values">Actual Values</span><a href="#actual-values" class="header-anchor">#</a></h3><p>通常来讲， <em>used value</em> 就是最终用来去渲染的值。但是，有些时候<em>user agent</em> 无法在给定的环境当中使用该值。<br>比如，user agent可能只能使用整数像素来渲染 border，如果used value是浮点数，就不得不对该值进行近似处理。<br>而 <em>actual value</em> 就是经过近似处理后的可以使用的 <em>used value</em>。</p><p>到这里，我们已经基本对元素属性值的计算过程有了详细的了解。</p><h2><span id="ji-cheng">继承</span><a href="#ji-cheng" class="header-anchor">#</a></h2><p>属性值的继承主要出现在获取 <em>specified value</em> 的第二步。也就是说 在层叠无法给出一个值的情况下，如果该 属性是可以继承的并且该元素不是DOM树的根元素，<em>specified value</em>就等于父元素的 <em>computed value</em> 。<br>在继承发生的情况下， 子元素属性继承 父元素的 <em>computed values</em>。换句话讲，该子元素的这个属性的 <em>specified value</em> 和 <em>computed value</em> 都等于其父元素该属性的 <em>computed value</em> 。</p><p>分析下面的代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">body &#123;font-size: 10pt&#125;</span></div><div class="line"><span class="undefined">h1 &#123;font-size: 130%&#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>A  <span class="tag">&lt;<span class="name">em</span>&gt;</span>large<span class="tag">&lt;/<span class="name">em</span>&gt;</span>  heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p><p> 根据规范：</p><ol><li><code>h1 element</code>的 <code>font-size</code>属性的<em>computed value</em> 为 <code>13pt</code>（<code>130% * 10pt</code>）. </li><li><code>em element</code>的 <code>font-size</code>属性值可以继承，因此<code>em element</code>的 <code>font-size</code>的 <em>specified value</em> 和 <em>computed value</em> 都为 <code>13pt</code>. 如果<em>user agent</em> 没有可用的<code>13pt</code>字体，那么 <code>font-size</code> 的 <em>actual value</em> 可能是其他值，比如 <code>12pt</code>.</li></ol><p><strong>Note</strong>: 继承遵循DOM树, 并且不会被 <em>anonymous boxes</em> 给截断。</p><h3><span id="ceng-die-zhong-de-inherit-zhi">层叠中的 <code>inherit</code> 值</span><a href="#ceng-die-zhong-de-inherit-zhi" class="header-anchor">#</a></h3><p>每一个属性也可能有一个<code>inherit</code> 层叠值。 <code>inherit</code> 层叠值可以用来显示实现属性值的继承，也就是说它可以用在一些本身不是继承的属性上。另外需要注意的是如果<code>inherit</code>被设置在根元素上面，该属性会被赋值为<em>initial value</em>.</p><h2><span id="the-cascade-ceng-die">The Cascade(层叠)</span><a href="#the-cascade-ceng-die" class="header-anchor">#</a></h2><p>样式表通常可能有三个来源：author, user 和 user agent。我们分开来了解一下：</p><ul><li><strong>author</strong>: author根据文档语言约定来给源文档指定样式表。比如，在HTML当中，样式表可以包含在文档中(<code>&lt;style&gt;&lt;/style&gt;</code>)或者来自外部链接(<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;theme.css&quot; /&gt;</code>)。</li><li><strong>user</strong>：用户可能会给特殊的文档指定样式信息。比如，用户可以指定一个包含样式表的文件或者user agent提供一个界面来让用户生成用户样式表。</li><li><strong>user agent</strong>:  user agent必须应用一份默认样式表(或者表现的它做了一样)。user agent的默认样式表需要按照满足文档语言的一般表现预期的方式来呈现文档语言元素（比如对于可视化浏览器，HTML中的<code>em</code> 元素应该按照斜体来表示）。CSS2中推荐的 <a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/sample.html" target="_blank" rel="external">默认样式表</a></li></ul><p><strong>那么问题来了，当不同来源的样式表相互重叠时，我们该运用哪一个样式表呢？</strong><br>上述的3种样式表将在一定范围内重叠，并且他们按照重叠互相影响。<br><strong>因此，CSS层叠给每一个样式规则赋予了权重，权重最高的规则将会被使用。</strong></p><p>默认情况下：</p><ul><li>author style sheet的规则比 user style sheet的规则的权重更高。但是对于 <code>!important</code>规则，优先级是相反的。</li><li>所有author style sheet和user style sheet的规则都比 UA的默认样式表的规则的权重更高。</li></ul><h3><span id="cascading-order-ceng-die-shun-xu">cascading order(层叠顺序)</span><a href="#cascading-order-ceng-die-shun-xu" class="header-anchor">#</a></h3><p>为了找出一个 <code>element property</code>的值，user agents按照下面的步骤来排序：</p><ol><li>找出target media type下面，所有适用于该元素和目标属性的声明。</li><li>根据importance(normal or important)和origin(author, user, user agent)来升序优先级排序：<ol><li>user agent 声明</li><li>user normal 声明</li><li>author normal 声明</li><li>author important 声明</li><li>user important 声明</li></ol></li><li>对于相同importance 和 origin的规则按照选择器的 <code>specificity</code>来排序。更特殊的选择器规则将会覆盖一般的。另外，对于pesudo-elements 和 pesudo-classes分别按照<em>normal elements</em> 和 <em>normal class</em> 对待。</li><li>最后，按照指定的顺序(也就是出现的先后顺序)来排序：也就是说，在权重，origin和specificity相同的情况下，出现在后免得被指定的声明将会被采用(通过<code>@import</code>引入的样式表声明将被认为在样式表自身的所有声明之前)。</li></ol><h3><span id="important-gui-ze"><code>!important</code> 规则</span><a href="#important-gui-ze" class="header-anchor">#</a></h3><p>我一直觉得想要真正的理解一门技术，一个技术的知识点。我们得带入自己到技术开发者的环境中，了解技术出现的历史背景、想要解决的问题。<br>CSS规范作者一直尝试在author和user样式表之间建立平衡。因此，默认情况下，author样式表的规则会覆盖user样式表的规则。<br>但是为了平衡，<code>!important</code>声明比normal声明优先级更高。如果author样式表和user样式表都包含<code>!important</code>声明，那么user的<code>!important</code>声明会覆盖author的<code>!important</code>规则。这样的目的是给与用户在表现上的特殊需求的控制，来提高用户的访问效果。</p><p><strong>Note</strong>: 赋予简写属性(比如<code>background</code>)<code>!important</code>规则，等价于给所有的子属性都赋予<code>!important</code>规则。</p><h3><span id="ji-suan-xuan-ze-qi-de-specificity">计算选择器的 specificity</span><a href="#ji-suan-xuan-ze-qi-de-specificity" class="header-anchor">#</a></h3><p>CSS规范当中在计算选择器的<code>specificity</code>时候采用了<code>a, b, c, d</code>四个变量，优先级为降序。下面是具体变量的计算方式：</p><ul><li>如果声明来自元素的<code>style</code>属性而不是选择器样式规则，那么<code>a=1</code>，否则为0</li><li>计算选择器中ID属性的数量(=b)</li><li>计算选择器中其他属性和伪类的数量(=c)</li><li>计算选择器中元素名和伪元素的数量(=d)</li></ul><p>这里，需要强调的是，选择器的<code>specificity</code>只根据选择器的形式来定。<br>举个例子， <code>[id=p33]</code>形式的选择器只被算作是一个属性选择器(<code>a=0, b=0, c=1, d=0</code>),尽管id属性在源文档的DTD中被定义为ID。</p><p>下面，我们给出详细的例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">*             &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span></div><div class="line"><span class="selector-tag">li</span>            &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span></div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-line</span> &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span>         &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span>+<span class="selector-tag">li</span>      &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span></div><div class="line"><span class="selector-tag">h1</span> + *<span class="selector-attr">[rel=up]</span>&#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-class">.red</span>  &#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span></div><div class="line"><span class="selector-tag">li</span><span class="selector-class">.red</span><span class="selector-class">.level</span>  &#123;&#125;  <span class="comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span></div><div class="line"><span class="selector-id">#x34y</span>         &#123;&#125;  <span class="comment">/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span></div><div class="line">style=""          /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</div></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">        <span class="selector-id">#x97z</span>&#123;<span class="attribute">color</span>: red;&#125;</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"x97z"</span> <span class="attr">style</span>=<span class="string">"color: green;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><p>上面的html代码根据层叠规则3，<code>style=&quot;color: green;&quot;</code>的特殊性要高于选择器<code>#x97z{color: red;}</code>, 因此p元素的color值为green。</p><p><strong>note</strong>: 这里对于HTML中的表现型属性（比如color）被翻译成相应的特殊性为0的CSS规则不做过多的讨论。</p><h2><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h2><p>到这里为止，我们应该可以很好地回答在introduction当中提出的4个问题了。</p><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><ol><li><a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html#computed-value" target="_blank" rel="external">6 Assigning property values, Cascading, and Inheritance</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#yue-du-zhu-yi-shi-xiang&quot;&gt;阅读注意事项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;/li
      
    
    </summary>
    
      <category term="CSS" scheme="http://www.bruceyj.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.bruceyj.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>深入前端之replaced element</title>
    <link href="http://www.bruceyj.com/2019/02/12/2019-2-12-deep-into-front-end-replaced-element/"/>
    <id>http://www.bruceyj.com/2019/02/12/2019-2-12-deep-into-front-end-replaced-element/</id>
    <published>2019-02-12T10:23:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#yue-du-zhu-yi-shi-xiang">阅读注意事项</a></li><li><a href="#introduction">introduction</a></li><li><a href="#shi-me-shi-replaced-element">什么是<code>replaced element</code></a></li><li><a href="#shi-me-shi-intrinsic-dimensions">什么是<code>intrinsic dimensions</code></a></li><li><a href="#html-zhong-you-na-xie-yuan-su-ke-yi-bei-cheng-wei-replaced-element">HTML中有哪些元素可以被称为<code>replaced element</code></a></li><li><a href="#zong-jie">总结</a></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --></div><h2><span id="yue-du-zhu-yi-shi-xiang">阅读注意事项</span><a href="#yue-du-zhu-yi-shi-xiang" class="header-anchor">#</a></h2><ol><li>本篇文章的依赖主要是<strong>CSS specification</strong> 和 <strong>html standard</strong>。</li><li>本篇整体比较细节和理论，可能会看起来枯燥，我尽量讲的逻辑简单些。个人认为有时候阅读枯燥的理论文章是有必要的。</li><li>写这篇的文章主要目的在于完善自己的知识体系。因此希望大家能够多多指出文章中不恰当之地方。</li></ol><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>在阅读<a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#inline-width" target="_blank" rel="external">CSS2 visual formatting model details</a>时，里面出现了大量的关于<code>replaced element</code>和<code>non-replaced element</code>的概念。<code>visual formatting model details</code>中将element在<code>inline-level and block-level</code>和<code>replaced and non-replaced</code>两个不同的维度展开描述。因此，如果我们想要深入理解CSS的内部世界，那么理解<code>replaced element</code>的概念就是必不可少的了。</p><p>那么本篇笔记主要解决下面几个问题：</p><ol><li>什么是<code>replaced element</code>?  </li><li>什么是<code>intrinsic dimensions</code>?</li><li>实际开发中如何计算<code>replaced element</code>的尺寸?</li><li>对于前端来讲，HTML中具体有哪些elments可以被认为是<code>replaced element</code>?</li></ol><h2><span id="shi-me-shi-replaced-element">什么是<code>replaced element</code></span><a href="#shi-me-shi-replaced-element" class="header-anchor">#</a></h2><p>w3c css2.2中对<code>replaced element</code>有一段简短的描述(来源于<a href="https://drafts.csswg.org/css2/conform.html" target="_blank" rel="external">3.conformance: Requirements and Recommendations</a>):</p><blockquote><p>An element whose content is outside the scope of the CSS formatting model, such as an image, embedded document, or applet. For example, the content of the HTML IMG element is often replaced by the image that its “src” attribute designates. Replaced elements often have intrinsic dimensions: an intrinsic width, an intrinsic height, and an intrinsic ratio. For example, a bitmap image has an intrinsic width and an intrinsic height specified in absolute units (from which the intrinsic ratio can obviously be determined). On the other hand, other documents may not have any intrinsic dimensions (for example, a blank HTML document).</p></blockquote><p> 从这段基本的描述中，我们可以总结出什么：</p><ol><li><code>replaced element</code>的content处于CSS formatting model控制之外。</li><li>常见的<code>replaced element</code>比如<code>image</code>, <code>embedded document</code>, <code>applet</code></li><li><code>replaced element</code>通常包含<code>intrinsic dimensions</code>: <em>intrinsic width, intrinsic height, intrinsic ratio</em>。但是并不是所有的<code>replaced element</code>都同时包含这三个属性值。</li><li>推论：<code>replaced element</code>之所以冠以<code>replaced</code>的形容词，是因为这类element的内容会被指向的外部资源给replace掉。</li></ol><p>上述的描述中引入一个新的名词<code>intrinsic dimensions</code>. 那么，我们来看一看什么事<code>intrinsic dimensions</code>.</p><h2><span id="shi-me-shi-intrinsic-dimensions">什么是<code>intrinsic dimensions</code></span><a href="#shi-me-shi-intrinsic-dimensions" class="header-anchor">#</a></h2><p>从文字意义上来看，<code>intrinsic dimensions</code>表示的是<em>内部尺寸</em>。</p><p>另外，w3c CSS2.2中同样对<code>intrinsic dimensions</code>给出了一段简短的描述:</p><blockquote><p>The width and height as defined by the element itself, not imposed by the surroundings. CSS does not define how the intrinsic dimensions are found. In CSS 2 only replaced elements can come with intrinsic dimensions. For raster images without reliable resolution information, a size of 1 px unit per image source pixel must be assumed.</p></blockquote><p>从上面的定义中我们可以总结出几点：</p><ol><li>CSS2中只有<code>replaced element</code>有<code>intrinsic dimensions</code>.</li><li><code>replaced element</code>的<code>width</code>和<code>height</code>都由<code>element</code>自己定义.</li></ol><p>但是，我们光从上面的定义中很难真正的理解<code>intrinsic dimensions</code>.<br>因此我们再来看CSS3，<a href="https://www.w3.org/TR/css3-images/" target="_blank" rel="external">CSS Image Values and Replaced Content Module Level 3 5.1小节</a>有更加精确的定义：</p><blockquote><p>The term intrinsic dimensions refers to the set of the intrinsic height, intrinsic width, and intrinsic aspect ratio (the ratio between the width and height), each of which may or may not exist for a given object.<br>These intrinsic dimensions represent a preferred or natural size of the object itself; that is, they are not a function of the context in which the object is used. CSS does not define how the intrinsic dimensions are found in general.<br>Raster images are an example of an object with all three intrinsic dimensions. SVG images designed to scale might have only an intrinsic aspect ratio; SVG images can also be created with only an intrinsic width or height. CSS gradients, defined in this specification, are an example of an object with no intrinsic dimensions at all. Another example of this is embedded documents, such as the<code>&lt;iframe&gt;</code> element in HTML. An object cannot have only two intrinsic dimensions, as any two automatically define the third.<br>If an object (such as an icon) has multiple sizes, then the largest size (by area) is taken as its intrinsic size. If it has multiple aspect ratios at that size, or has multiple aspect ratios and no size, then the aspect ratio closest to the aspect ratio of the default object size is used. Determine this by seeing which aspect ratio produces the largest area when fitting it within the default object size using a contain fit; if multiple sizes tie for the largest area, the wider size is chosen as its intrinsic size.</p></blockquote><p>上面的definition主要包含4大块内容：</p><ol><li>术语<code>intrinsic dimensions</code>通常指代<code>intrinsic height</code>， <code>intrinsic width</code>, <code>intrinsic aspect ratio(width / height)</code>三种值的集合。但是对于不同<code>replaced element</code>中的<code>object</code>来讲，这三种value不一定都会存在。</li><li><code>intrinsic dimensions</code>表示的是引入<code>object</code>的自己的<code>natural size</code>,也就意味着这是和<code>context</code>无关的。通常来讲，CSS并不会定义如何获得<code>intrinsic dimensions</code>.</li></ol><p>这里如果仔细的话，我们这里使用了<code>element</code>和<code>object</code>两个名词。使用两个不同的名词是有一定的目的的。首先我们在<a href="https://html.spec.whatwg.org/multipage/rendering.html#replaced-elements" target="_blank" rel="external">html specific replaced element</a>中了解到<code>html</code>中的<code>replaced element</code>可以是<code>&lt;audio&gt;</code>,<code>&lt;img&gt;</code>,<code>&lt;canvas&gt;</code>,<code>&lt;embed&gt;</code>,<code>&lt;iframe&gt;</code>,<code>&lt;input&gt;</code>, <code>&lt;object&gt;</code>, <code>&lt;video&gt;</code>这几种。另外我们在什么是<code>replaced element</code>小节中推论到，<code>replaced element</code>之所以冠以<code>replaced</code>的形容词，是因为这类element的内容会被指向的外部资源给replace掉。所以这里就使用了<code>element</code>和<code>object</code>两个名词，<code>object</code>表示引入的外部资源本身，资源本身会有自己固定的的<code>dimensions</code>。<br><strong>Note</strong>：但是，这并不意味着我们无法使用<code>CSS</code>来控制<code>html element</code>的外部展示，CSS控制<code>replaced element</code>的布局和<code>intrinsic dimension</code>两者并不冲突。具体细节可以看下面<code>concrete object size</code>的算法。</p><ol><li>主要是几个例子。<code>raster image</code>这个<code>object</code>同时拥有3个<code>intrinsic dimensions value</code>。<code>SVG iamges</code>可能只拥有一个<code>intrinsic aspect ratio</code>或者<code>intrinsic width</code>或者<code>intrinsic height</code>.<code>CSS gradient</code>3种<code>intrinsic dimension value</code>都没有。</li><li>主要是一些边界情况，比如如果一个<code>object</code>有多个<code>size</code>。那么该选择哪一个？规范中是<code>largest size</code>将会作为该<code>object</code>的<code>intrinsic size</code>.如果有多个<code>aspect ratio</code>值，那么最接近<code>ratio of the default object size</code>的<code>aspect ratio</code>将会被选择。如果<code>default object size</code>使用<code>contain fit</code>的话，产生最大area的<code>aspect ratio</code>将会被选择。</li></ol><p><strong>但是，这些定义对于我们实际开发当中有什么用呢？ 换个角度来讲，就是我们在实际开发中，<code>replaced element</code>的布局与尺寸该如何来计算呢？</strong></p><p>要给出上面的答案，我们可能还需要知道更多相关的名词：</p><blockquote><p><strong>specified size</strong><br>The specified size of an object is given by CSS, such as through the ‘width’ and ‘height’ or ‘background-size’ properties. The specified size can be a definite width and height, a set of constraints, or a combination thereof.<br><strong>concrete object size</strong><br>The concrete object size is the result of combining an object’s intrinsic dimensions and specified size with the default object size of the context it’s used in, producing a rectangle with a definite width and height.<br><strong>default object size</strong><br>The default object size is a rectangle with a definite height and width used to determine the concrete object size when both the intrinsic dimensions and specified size are missing dimensions.</p></blockquote><p>有上面的定义可以知道：</p><ol><li><strong>specified size</strong>: <em>specified size</em>由CSS指定，比如通过<code>width</code>、<code>height</code>、<code>background-size</code>属性。<em>specified size</em>可以是有限的width和height, constraints集合或者两者的结合。</li><li><strong>concrete object size</strong>:  <em>concrete object size</em>由<em>object’s intrinsic dimensions</em>, <em>specified size</em>和<em>default object size</em>这三者决定，产生一个有<em>definite width and height</em>的矩形。</li><li><strong>default object size</strong>: <em>default object size</em>是一个有<em>definite height and width</em>的矩形。</li></ol><p>理解了上面三种<code>size</code>的定义，我们开始来看看在规范的<a href="https://www.w3.org/TR/css3-images/#object-negotiation" target="_blank" rel="external">5.2 CSS Object Negotiation</a>中<strong>Objects in CSS 的size</strong>是如何被决定并且渲染的：</p><blockquote><ol><li>When an image or object is specified in a document, such as through a ‘url()’ value in a ‘background-image’ property or an src attribute on an <code>&lt;img&gt;</code> element, CSS queries the object for its intrinsic dimensions.</li><li>Using the <code>intrinsic dimensions</code>, the <code>specified size</code>, and the <code>default object size</code> for the context the image or object is used in, CSS then computes a <code>concrete object size</code>. (See the following section.) This defines the size and position of the region the object will render in.</li><li>CSS asks the object to render itself at the concrete object size. CSS does not define how objects render when the concrete object size is different from the object’s intrinsic dimensions. The object may adjust itself to match the concrete object size in some way, or even render itself larger or smaller than the concrete object size to satisfy sizing constraints of its own.</li><li>Unless otherwise specified by CSS, the object is then clipped to the concrete object size.</li></ol></blockquote><ol><li>第一步，当<code>image or object</code>在document当中被指定（比如<code>background-image</code>通过<code>url()</code>或者<code>&lt;img&gt;</code> element通过<code>src</code>来指定），CSS会先去查找<code>object</code>的<code>intrinsic size</code>.</li><li>第二步，浏览器根据<code>intrinsic dimensions</code>,  <code>specified size</code>, 和 <code>default object size</code>来计算出<code>concrete object size</code>(具体计算方法看下面).</li><li>第三步，CSS通知<code>object</code>根据<code>concrete object size</code>来渲染自己。CSS并没有规定当<code>concrete object size</code>和<code>intinsic dimensions</code>不一样的时候该如何渲染。<code>object</code>可能会自己调整自己来适应<code>concrete object size</code>或者为了满足自己的sizing constraints来大于或小于<code>concrete object size</code>。</li><li>第四步，除非CSS另有指定，不然<code>object</code>会被剪切为<code>concrete object size</code>大小。</li></ol><p>下面我们展开来讲解一下第二步- 如何确定<code>concrete object size</code>。在规范<a href="https://www.w3.org/TR/css3-images/#concrete-size-resolution" target="_blank" rel="external">5.3. Concrete Object Size Resolution</a>中介绍了<code>Default Sizing Algorithm</code>:</p><ol><li>如果<code>specified size</code>是有限的<code>width</code>和<code>height</code>，那么<code>concrete object size</code>的值就是<code>specified size</code>.</li><li>如果<code>specified size</code>只有<code>width</code>或<code>height</code>其中一个。那么<code>concrete object size</code>的相同属性的值为<code>specified size</code>提供。另外一个值由以下方式来计算：<ol><li>如果该object拥有<code>intrinsic aspect ratio</code>, 那么<code>concrete object size</code>将使用<code>intrinsic aspect ratio</code>来计算。</li><li>否则的话，我们再看缺少的dimension是否在<code>object</code>的<code>intrinsic dimensions</code>中存在，如果存在，则取用该值。</li><li>否则的话，<code>concrete object size</code>缺少的dimension则取用<code>default object size</code>.</li></ol></li><li>如果<code>specified size</code>没有任何的constraints：<ol><li>如果object有<code>intrinsic height</code>或者<code>intrinsic width</code>，那么该<code>concrete object size</code>由<code>intrinsic size</code>来决定。</li><li>否则的话，<code>concrete object size</code>则被当做是相对于<code>default object size</code>的<code>contain constraint</code>。</li></ol></li></ol><p>另外，我们需要了解两个常见的<code>specified sizes</code>：<code>contain constraint</code>和<code>cover constraint</code>.两者都是通过<code>constraint rectangle</code>和<code>object&#39;s intrinsic aspect ratio</code>来决定<code>concrete object size</code>的大小。</p><ul><li><code>contain constraint</code>: <code>concrete object size</code>将会被设置为一个根据<code>object&#39;s intrinsic aspect ratio</code>计算出来的最大的rectangle，并且该rectangle的width或height都各自比<code>constraint rectangle</code>的<code>wdith</code>和<code>height</code>小或相等。</li><li><code>cover constraint</code>:<code>concrete object size</code>会被设置成一个根据<code>object&#39;s intrinsic aspect ratio</code>计算出来的最小的rectangle，并且该rectangle的width或height都各自比<code>constraint rectangle</code>的<code>width</code>和<code>height</code>大或相等。 </li><li>在上面两种情况下，如果object没有<code>intrinsic aspect ratio</code>，那么<code>concrete object size</code>就是specified constraint rectangle.</li></ul><h2><span id="html-zhong-you-na-xie-yuan-su-ke-yi-bei-cheng-wei-replaced-element">HTML中有哪些元素可以被称为<code>replaced element</code></span><a href="#html-zhong-you-na-xie-yuan-su-ke-yi-bei-cheng-wei-replaced-element" class="header-anchor">#</a></h2><p>从上面的内容，我可以知道<code>replaced element</code>的定义和计算细节。那么HTML中有哪些元素可以被称为<code>replaced element</code>呢？<br>这个我们得从<a href="https://html.spec.whatwg.org/multipage/rendering.html#replaced-elements" target="_blank" rel="external">HTML standard 14.4 replaced element</a>中来看。<br>规范中主要将<code>replaced element</code>分为两大类：</p><ol><li><p><strong>Embedded content(嵌入内容)</strong>:</p><ul><li>首先，<code>&lt;embed&gt;</code>, <code>&lt;iframe&gt;</code>, <code>&lt;video&gt;</code> 这三种元素被看作是<code>replaced elements</code>.</li><li>对于<code>&lt;canvas&gt;</code>元素来讲，如果<code>&lt;canvas&gt;</code>中代表的是<em>embedded content</em>,那么该<code>&lt;canvas&gt;</code>元素也被当作<em>replaced element</em>(比如<code>&lt;canvas&gt;</code>中的content是<em>bitmap</em>)。否则的话，<code>&lt;canvas&gt;</code>会被看作是普通的<em>rendering model</em>中的元素。</li><li>对于<code>&lt;object&gt;</code>元素来讲，和<code>&lt;canvas&gt;</code>一样得分为两种情况。<code>&lt;object&gt;</code>中展示的是<em>image, plugin, nested browsing context(比如iframe)</em> 时被看做是<em>replaced element</em>.其他情况下被认为是普通元素。</li><li>对于<code>&lt;audio&gt;</code>来讲，通常browser会对这类元素有对应的<em>user interface</em>，如果<code>&lt;audio&gt;</code>的<em>user interface</em>被展示，那么<code>&lt;audio&gt;</code>就会被认为是<code>replaced element</code>.</li></ul></li><li><p><strong>Images</strong>: <em>HTML</em>当中中<em>images</em>主要分为2种：<code>&lt;img&gt;</code>和<code>&lt;input type=&quot;image&quot;&gt;</code><br><em>user agent</em>主要按照下面的规则来render上面两种元素：</p><ul><li>如果该元素展示的<em>image</em>: 那么<em>user agent</em>将认为该元素是<code>replaced element</code>，并且根据CSS来render。</li><li>如果该element不展示<em>image</em>,但是该element包含<code>intrinsic dimensions</code>（比如来自dimension attributes 或CSS rules）- 该element被认为是<code>replaced element</code>:<ul><li><em>user agent</em>认为image在将来会是肯用的并且会在适当的时候被render</li><li>或者 element没有<code>alt attribute</code></li><li>或者当前<code>document</code>处于<code>quirks mode</code>.</li></ul></li><li>如果<code>&lt;img&gt;</code> element表示的是一些文本并且user agent不希望其发生改变： 该元素被看做是<code>non-replaced phrasing element</code></li><li>如果<code>&lt;img&gt;</code> element表示的是nonthing,并且user agent不希望其发生改变：该元素被看做是<code>empty inline element</code></li><li>如果<code>input element</code>不展示image并且user agent不希望其发生改变：那么该element被看做是<code>replaced element</code>（元素包含一个button，button的内容是element的可替换内容）。</li></ul></li></ol><p><strong>Note</strong>：1.  对于<code>embed, iframe, img, object</code>元素或者<code>&lt;input type=&quot;image&quot;&gt;</code>元素的<code>align attribute</code>等于<code>center or middle</code>时，该element的<code>vertical-align</code>将会被设定为value（element的vertical middle和parent element baseline 对齐）。</p><h2><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h2><p>到这里为止，我们基本已经能够来回答在<em>introduction</em>中提出的4个问题。对于更多的细节（比如<code>width</code>和<code>height</code>如何计算等等）可以看specification。</p><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><ol><li><a href="https://drafts.csswg.org/css2/conform.html" target="_blank" rel="external">3.conformance: Requirements and Recommendations</a></li><li><a href="https://www.w3.org/TR/css3-images/" target="_blank" rel="external">CSS Image Values and Replaced Content Module Level 3</a></li><li><a href="https://html.spec.whatwg.org/multipage/rendering.html#replaced-elements" target="_blank" rel="external">HTML standard 14.4 replaced element</a></li><li><a href="https://www.sitepoint.com/replaced-elements-html-myths-realities/" target="_blank" rel="external">Replaced Elements in HTML: Myths and Realities</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#yue-du-zhu-yi-shi-xiang&quot;&gt;阅读注意事项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;/li
      
    
    </summary>
    
      <category term="Front End" scheme="http://www.bruceyj.com/categories/Front-End/"/>
    
    
      <category term="Front End" scheme="http://www.bruceyj.com/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Computer Science中的funarg problem</title>
    <link href="http://www.bruceyj.com/2018/12/20/2018-12-20-deep-into-funarg-problem/"/>
    <id>http://www.bruceyj.com/2018/12/20/2018-12-20-deep-into-funarg-problem/</id>
    <published>2018-12-20T22:23:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#introduction">introduction</a></li><li><a href="#terminology-zhu-yu">terminology(术语)</a><ul><li><a href="#first-class-citizen-he-first-class-function">first-class citizen 和 first-class function</a></li><li><a href="#non-local-variable-he-closure">non-local variable 和 closure</a></li><li><a href="#stack-based-memory-allocation-he-heap-based-memory-allocation">stack-based memory allocation 和 heap-based memory allocation</a></li><li><a href="#tail-call-he-tail-recursion">tail call 和 tail recursion</a></li></ul></li><li><a href="#funarg-problem">Funarg problem</a><ul><li><a href="#upwards-funarg-problem">upwards funarg problem</a></li><li><a href="#downwards-funarg-problem">downwards funarg problem</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#reference">Reference</a></li></ul><!-- tocstop --></div><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>本篇主要是对computer science领域当中的Funarg problem以及涉及到的知识概念进行学习讨论。<br>很多人会有疑问，学习这些相关理论的意义在于何处，看起来对于自己的工作开发没什么明显的作用，但在我的理解当中这些理论就是CS世界的基石。举个简单的例子，世界上有N多种编程语言，但上升到语言学概念，很多语言的特性是类似的，构造也是类似的，解决的问题也是类似的。而通过学习这些理论会很好的让我们理解各个语言的特性的共同点和不同点，也会更好的理解自己所在的行业，而不是整天局限在前端、后端这种简单的职业划分或者某一种语言当中。</p><h2><span id="terminology-zhu-yu">terminology(术语)</span><a href="#terminology-zhu-yu" class="header-anchor">#</a></h2><p>本篇会牵扯到一些专业术语，而对于出现的这些术语我一般不会翻译成中文（对专业词汇的认识还是很有必要的）。</p><ul><li>first-class citizen</li><li>first-class function</li><li>-closure</li><li>non-local variable</li><li>stack-based memory allocation</li><li>heap-based memory allocation</li><li>call stack</li><li>funarg problem</li><li>tail call</li><li>tail recursion</li></ul><h3><span id="first-class-citizen-he-first-class-function">first-class citizen 和 first-class function</span><a href="#first-class-citizen-he-first-class-function" class="header-anchor">#</a></h3><blockquote><p>first-class object(first-class citizen): 在编程语言的设计当中，如果一个entity支持其他entity支持的所有操作，那么该entity可以被叫做first-class citizen,也就是常说的一等公民。这些操作通常包括 passed as an argument, returned from a function, modified 和 assigned to a variable.</p></blockquote><p>我们来实际看一下，目前流行的编程语言对于first-class citizen的实现：</p><ul><li>在一些出现比较早的编程语言当中arrays和strings不是first-class. 比如C语言当中不支持array assignment,如果我们在C中将一个array传递给function，实际上只是该array的第一个element被传递(C支持以array pointer的方式来assignment).<ul><li>在大部分语言中，data types 不是first-class，尽管在一些OO语言当中，class是first-class objects并且是metaclass的instance,比如Python。</li></ul></li></ul><blockquote><p>first-class function: 在该编程语言当中，function属于first-class citizen.</p></blockquote><p>很明显，一个支持first-class function的编程语言，需要支持以下几种特性：</p><ul><li>passing functions as arguments to other functions(function可以成为函数的参数)</li><li>returning them as the values from other functions（function的返回值可以使function类型）</li><li>assigning them to variables（function可以用来赋值）</li><li>storing them in data structures（function可以保存在数据结构中）<br><strong>note 1</strong>：在支持first-class function的语言当中，function的name没有什么特殊地位，它们只是function type的variables。  另外，支持first-class function对于function proagramming是必须的。</li></ul><p><strong>note 2</strong>: first-class function还会引申到另外一个概念: higher-order function(高阶函数)，详细了解可以查看<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">reference 6</a></p><p>下面，我们来了解一下该如何test function for equality(比较function).首先，我们了解一下通常比较的几种方式：</p><ul><li>Extensional equality: 如果要使两个function <code>f</code>和<code>g</code>被认为extensional equality,只要他们对于all inputs都有相同的outputs(<code>∀x. f(x) = g(x)</code>)。举个例子，两个stable sorting算法的实现有很多种(比如insertion sort和merge sort)，不同sort算法的实现会被认为extensional equality因为对于所有的input都有相同的output.这对于语言实现来讲非常难，所以没有编程语言支持该特性。</li><li>Intensional equality： 只要两个function有相同的internal structure，那么这两个function就被认为Intensional equality.比如Lisp1.5就在interpreted阶段实现了该特性。</li><li>Reference equality: 这是目前大部分语言支持的equality。在这些语言当中，所有的function都会被赋值一个unique identifier(通常是function body的内存地址)，而两个function的比较就是对应的identifier的比较，只要两个identifier指向同一块内存地址，那么久认为两个function是相等的。</li></ul><p>总结来说，这3种比较方式的比较严格程度依次增强.：extensional equality &lt; intensional equality &lt; reference equaltiy.</p><p>讲了这么多，我们看看目前编程语言对于first-class function的支持(图表更加直观)：</p><ul><li>functional programming languages: 比如 Scheme， ML, Haskell, Scala都从语言层面上支持first-class functions. 在最早的functional language - lisp被创造的时候，很多关于first-class function的概念还没有被很合理的理解，这也导致lisp在早期实现first-class function是通过dynamically scoped来实现的。但是在后来的Common Lisp和scheme这两个dialect当中已经通过lexically scoped来实现first-class functions了.</li><li>很多scripting language，比如Perl, Python, PHP, Lua,Javascript都支持first-class function.</li><li>对于imperative languages，主要分为两个家族，Algol family和C family。具体区别看下面的图表。<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181220-first-class-function.png" alt="first-class function"></li></ul><h3><span id="non-local-variable-he-closure">non-local variable 和 closure</span><a href="#non-local-variable-he-closure" class="header-anchor">#</a></h3><blockquote><p>closure(闭包): 简单来讲，在编程语言当中, a closure (also lexical closure or function closure) 是指用来实现lexically scoped name binding(由first-class function造成)的一种技术.</p><p>non-local variable(free variable): 指该variable既不是定义在local scope当中，也不是global scope中，通常出现在nested or anonymous functions当中。</p></blockquote><p>下面我们通过简单的javascript代码来直观看一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f, g;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x;</div><div class="line">  f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> ++x; &#125;;</div><div class="line">  g = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> --x; &#125;;</div><div class="line">  x = <span class="number">1</span>;</div><div class="line">  alert(<span class="string">'inside foo, call to f(): '</span> + f());</div><div class="line">&#125;</div><div class="line">foo();  <span class="comment">// 2</span></div><div class="line">alert(<span class="string">'call to g(): '</span> + g());  <span class="comment">// 1 (--x)</span></div><div class="line">alert(<span class="string">'call to g(): '</span> + g());  <span class="comment">// 0 (--x)</span></div><div class="line">alert(<span class="string">'call to f(): '</span> + f());  <span class="comment">// 1 (++x)</span></div><div class="line">alert(<span class="string">'call to f(): '</span> + f());  <span class="comment">// 2 (++x)</span></div></pre></td></tr></table></figure></p><p>很明显，我们从上面代码中可以看出，f和g都是nested function.而两个function都在各自内部依赖外部lexical scope的变量<code>x</code>,这就形成了closure。而这段代码中的free variable就是<code>x</code>.</p><h3><span id="stack-based-memory-allocation-he-heap-based-memory-allocation">stack-based memory allocation 和 heap-based memory allocation</span><a href="#stack-based-memory-allocation-he-heap-based-memory-allocation" class="header-anchor">#</a></h3><blockquote><p>stack-based memory allocation: 首先，我们知道stack是一种LIFO(last in first out)的data structure, 而stack-based memory allocation就是指基于stack的一种内存分配方式。</p><p>heap: 在CS领域当中，heap指的是专用的 tree-based data structure 。</p></blockquote><p>我们现在从computing architecture层面上来看stack，stack就是指的memory的部分区域。在大部分现代操作系统当中，每一个thread都有一块memory被用作stack。当function 被执行时，相关的环境会被压入stack当中，执行完该调用后在pop出来。因为stack-based memory allocation的执行方式是LIFO，因此它非常简单，也就导致存取速度快于heap-based memory allocation。</p><p><strong>note</strong>: 在很多small CPU当中，每个 thread被分配的 stack size很少，可能只有几bytes. 我们在开发过程当中，分配太多的stack memory可能会导致stack overflow.<br><strong>note</strong>：一些processer families,比如X86，会有一些特殊的命令来让我们操作executing thread的stack。另外一些其他的processor families，比如PowerPC,不支持直接的stack support，而是通过delegate stack management来处理。</p><h3><span id="tail-call-he-tail-recursion">tail call 和 tail recursion</span><a href="#tail-call-he-tail-recursion" class="header-anchor">#</a></h3><blockquote><p>tail call: 在CS领域当中，我们可以将程序划分成一个个procedure,如果在这个procedure的最后一个action当中执行的是subroutine call,那么我们可以称之为tail call.</p><p>tail recursion: 如果tail call在call chain当中都是进行的相同的subroutine，那么这种情况就被称为tail recursion，也就是尾递归。理论上尾递归只需要在call stack当中包含一个stack frame就足够了。</p></blockquote><h2><span id="funarg-problem">Funarg problem</span><a href="#funarg-problem" class="header-anchor">#</a></h2><blockquote><p>funarg problem:在CS领域当中，funarg problem指的是在编程语言的实现当中, 如何来实现first-class functions这个特性。实现该特性的难点通常出现在nested functions当中，比如我们在nested function直接引用non-local variables。解决思路通常有两种, 从语言层面禁止nested function或者支持closure.</p></blockquote><p>下面，我们简单看看语言当中是如何来实现该特性的。</p><ul><li>在早期imperative languages: 不支持functions as result types(比如ALGOL 60 或者Pascal)；忽略 nested function(也就不会出现non-local variables)（比如C）。</li><li>早期functional language: Lisp采用dynamic scoping来实现该特性(non-local variable的值由运行时决定，而不是function被定义时决定).</li><li>更加合理的Lexically scoped first-class function被scheme引入。但这也导致语言需要处理references to functions,这意味着garbage collection需要成为一个必要的特性。</li></ul><p>在CS当中，通常将funarg problem 分成 upwards funarg problem和downwards funarg problem.</p><ul><li>upwards funarg problem - 在function当中返回 function</li><li>downwards funarg problem - 将function当成parameter(实参)传递给另一个function call.</li></ul><h3><span id="upwards-funarg-problem">upwards funarg problem</span><a href="#upwards-funarg-problem" class="header-anchor">#</a></h3><p>首先，我们描绘一个简单的编程场景：<br>在很多的compiled language中，function的调用时通过call stack来实现的。<br>在一段程序执行中，我们在一个function(caller)执行当中调用了另外一个function(callee)。caller的local state(比如parameters和local variables)需要保存压入call stack当中，因为需要在callee执行完返回后来还原环境。在大部分compiled programs中，这些local state以stack frame(或者被叫做activation record)的数据结构存储。<br>以上面的情况来看，upwards funarg problem会出现是因为caller function需要依赖 callee function的当中的某些数据state，这就意味着callee在被调用完成后不能被deallocated(而这就和stack-based function call paradigm冲突)。</p><p>那么，作为一个语言设计者，我们该如何解决上述的问题：</p><ol><li>对于stack frames采取 heap-based memory allocation,并且依赖Garbage collection或者reference counting来deallocate stack frames。这种方案的缺点在于效率，会很明显的降低性能。</li><li>一些efficiency-minded compilers会采取一种Hybird的方案。通过 static program analysis来检测程序中的function有没有upwards funargs,如果没有则给该stack frame分配stack memory；否则，分配heap memory.</li><li>另外一个解决方案：在closure刚被创建的时候，将涉及到的non-local variables的值复制到closure当中。但是我们需要考虑一种情况，如果non-local variable是mutable variable将会导致该variable在所有的closures当中共享，这可能并不一定使我们想要的。因此，如果这些variables是constant的话，该方案是可接受的。 <strong>ML语言</strong>采用了这种方案（因为该语言中variables直接绑定到values，variables是不可改变的）。另外<strong>Java</strong>在anonymous class当中也采取了该方案，只允许在enclosing scope当中依赖 final variables.<br>另外一些语言允许开发者显式的选择这两种行为。比如PHP5.3当中，anonymous functions 可以在closure当中使用 <code>use() clause</code>来显式选择。比如Apple的 blocks anonymous functions 捕获variable默认是value，但是如果你想要共享state，你可以使用<code>__block</code> modifier来限定variable（该变量会被分配在heap上）。</li></ol><h3><span id="downwards-funarg-problem">downwards funarg problem</span><a href="#downwards-funarg-problem" class="header-anchor">#</a></h3><p>首先，我们来简单的看一段javascript代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">funArg</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> x = <span class="number">20</span>;</div><div class="line">  funArg(); <span class="comment">// 10, not 20!</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Pass `foo` as an argument to `bar`.</span></div><div class="line">bar(foo);</div></pre></td></tr></table></figure></p><p>对于函数 foo 来说，x 是自由变量。当 foo 函数被激活时（通过<br>funArg 参数） - 程序应该在哪里解析 x 的绑定？是创建函数的外部作用域还是调用函数的调用者作用域？正如我们所见，调用者即 bar 函数，也提供了 x 的绑定 - 值为 20.<br>抽象来讲，downwards funarg problem就是指我们该如何确定绑定的正确环境：应该是创建时的环境，还是调用时的环境（dynamic scope还是lexical scope）.<br>通常对于大部分现代编程语言，都是lexical scope，也就是创建时的环境。并且downwards funarg problem会复杂化tail recursion的编译效率。</p><h2><span id="conclusion">Conclusion</span><a href="#conclusion" class="header-anchor">#</a></h2><p>综上所述，我们基本能够理解funarg problem是什么问题，有哪些解决办法。理解这些基本CS概念能够帮我们更好地理解各个编程语言（比如javascript、python、java等等）。</p><h2><span id="reference">Reference</span><a href="#reference" class="header-anchor">#</a></h2><p>1.<a href="https://en.wikipedia.org/wiki/Funarg_problem" target="_blank" rel="external">Wiki, Funarg problem</a><br>2.<a href="https://en.wikipedia.org/wiki/First-class_citizen" target="_blank" rel="external">first-class citizen</a><br>3.<a href="https://en.wikipedia.org/wiki/First-class_function" target="_blank" rel="external">first-class function</a><br>4.<a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" target="_blank" rel="external">Stack-based memory allocation</a><br>5.<a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="external">tail call</a><br>6.<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">higher-order function</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#terminology-zhu-yu&quot;&gt;terminology(术语)&lt;/a&gt;
      
    
    </summary>
    
      <category term="Computer Science" scheme="http://www.bruceyj.com/categories/Computer-Science/"/>
    
    
      <category term="Computer Science" scheme="http://www.bruceyj.com/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>详细理解CSS中的outline</title>
    <link href="http://www.bruceyj.com/2018/10/23/2018-10-23-CSS-outline/"/>
    <id>http://www.bruceyj.com/2018/10/23/2018-10-23-CSS-outline/</id>
    <published>2018-10-23T21:23:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#introduction">introduction</a></li><li><a href="#syntax">syntax</a><ul><li><a href="#outline-and-border">outline and border</a></li><li><a href="#offsetting-the-outline-outline-offset-property">offsetting the outline: <code>outline-offset</code> property</a></li></ul></li><li><a href="#shi-yong">使用</a></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --><p></div></p><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>讲到outline，也就是我们通常所说的描边,我们要分成两个部分来理解:</p><ul><li>一个是shorthand CSS property: <code>outline</code>, 由<code>outline-style</code>、<code>outline-width</code>和<code>outline-color</code>组成</li><li>一个是独立的<code>outline-offset</code></li></ul><p>通常来讲，outline会被用在visual objects上面，比如buttons, active form fields等元素(make them stand out).</p><h2><span id="syntax">syntax</span><a href="#syntax" class="header-anchor">#</a></h2><p>首先很简单的是，我们知道<code>outline</code>由<code>outline-style</code>、<code>outline-width</code>、<code>outline-color</code>组成。<br><code>outline</code>的initial value:</p><ul><li><code>outline-color</code>: invert, for browsers supporting it, currentColor for the other</li><li><code>outline-style</code>: none</li><li><code>outline-width</code>: medium; 0 if <code>outline-style</code> is none.</li></ul><ol><li>outline-width允许的值和<code>border-width</code>一致</li><li>outline-style允许的值和<code>border-style</code>一致(除了缺少<code>hidden</code>).</li></ol><p><strong>Note</strong>:在CSS3当中，<code>outline-style</code>允许auto值。<code>auto</code> value允许user agent 去渲染一个定制的outline style(比如platform默认的style或者CSS表现不出来的style：a rounded edge outline with semi-translucent outer pixels that appears to glow).但是本规范并没有定义<code>outline-color</code>该如何表现在<code>outline-style</code>为auto的时候。并且UAs可能把<code>auto</code>解释为<code>solid</code>。</p><ol><li><code>outline-color</code>允许所有的colors。初始值是<code>inert</code>（确保focus border is visible）,但是需要注意的是很多UA是不支持<code>invert</code>值得，这个时候<code>outline-color</code>的initial value 就是<code>currentColor</code>。</li></ol><h3><span id="outline-and-border">outline and border</span><a href="#outline-and-border" class="header-anchor">#</a></h3><p>上面我们在理解outline的属性的时候，发现，<code>outline</code>的值和<code>border</code>是大同小异的。下面我们说一说不同点。</p><p>outline和border的不同点：</p><ul><li>outlines不会占据空间</li><li>outlines可能不是矩形的</li><li>UAs 经常在elments的<code>:focus</code> state渲染outlines</li></ul><ol><li><p>首先我们来了解一下第一点：outline不会占据空间。<br>这里的空间指的是布局空间。the outine is always on top并且不会影响box的position和size,也就不会导致reflow。</p></li><li><p>第二点，outlines may be non-rectangular.<br>举个例子，如果一个element被切割成多行，这个时候会产生多个element boxs.而outline的表现应该包裹住所有的element’s boxes（an outline or minimum set of outlines ）。outline的每一个部分需要fully connected（这里和border的表现是不一样的，比如inline elements在line被borken的时候会open on some sides）.这也是为什么说outlines are not required to be rectangular.<br>另外,outline会follow the border edge（但是目前对于follow the border-radius各大浏览器还没有支持）.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;span&gt;</div><div class="line">     love你love</div><div class="line">  &lt;/span&gt;     </div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">  margin: 100px auto;</div><div class="line">  width: 10px;</div><div class="line">&#125;</div><div class="line">span &#123;</div><div class="line">  outline: 5px solid red;</div><div class="line">  /*width: 15px;*/</div><div class="line">  border: 5px solid green;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181023-outline-non-rectangular.png" alt="outline-non-rectangular-chrome"><br>这是chrome、IE11和edge下的表现。<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181023-outline-non-rectangular-firefox.png" alt="outline-non-rectangular-firefox"><br>这是firefox下的表现.</p><p><strong>Note</strong>: outline的位置可能会受到desendant box的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">  .outline&#123;</div><div class="line">    width: 13px;</div><div class="line">    height: 13px;</div><div class="line">    outline: 1px solid red;</div><div class="line">  &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;div class=&quot;outline&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">  const el = document.querySelector(&quot;.outline&quot;)</div><div class="line">  el.textContent = !!~navigator.appVersion.indexOf(&quot;Chrome&quot;) ? &quot;Chrome&quot; : &quot;FireFox&quot;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181023-outline-desendant-box.png" alt="enter description here"><br><strong>Note</strong>: This specification does not define the exact position or shape of the outline, but it is typically drawn immediately outside the border box.</p><h3><span id="offsetting-the-outline-outline-offset-property">offsetting the outline: <code>outline-offset</code> property</span><a href="#offsetting-the-outline-outline-offset-property" class="header-anchor">#</a></h3><p>我们知道，默认情况下，outline被drawn在<code>border-edge</code>之外。但是，我们可以通过修改<code>outline-offset</code>来改变位置。</p><ul><li><code>outline-offset</code> 的initial value 为0.</li><li>允许正负值，负值时outline会收缩，正值时会扩张。</li></ul><p><strong>Note</strong>: 当outline的值为large negative value的时候，各个浏览器的表现是不一样的。<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181023-outline-edge-chrome.gif" alt="enter description here"><br>这是chrome下的表现，在outline-offset逐渐变小的时候，outline会变成十字形(具体的边界是在border-box的值 + outline-width的值，超过这个边界，outline会消失)<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181023-outline-edge-firefox.gif" alt="enter description here"><br>这是firefox下的表现<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181023-outline-edge.gif" alt="enter description here"><br>这是edge下的表现</p><p><strong>总结如下</strong>：<br>  上面3个动图分别是3个主流浏览器<code>outline-offset</code>值发生变化时的表现。chrome和edge的表现比较符合我们正常的感官，而firefox的表现就比较奇怪了。</p><h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor">#</a></h2><ol><li>可以用来模拟双层边框</li><li>用作focus indicators.<br><code>outline</code>通常可以被用于focus indicators。这些可以用于无障碍使用(web content Accessibility Guidelines).比如people who use screen readers or people with limited mobility.</li></ol><p>常见的focusable elements:</p><ul><li>Links</li><li>Buttons</li><li>Form Fileds / Controls (text fields, select boxes, radio buttons, etc.)</li><li>Menu items</li><li>Things triggerd by hober, like tooltips</li><li>Widgets, like a calendar picker</li></ul><p>那么如何设计一个useful and useable focus indicators可以看reference 2.</p><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><p>1.<a href="https://drafts.csswg.org/css-ui-3/#outline" target="_blank" rel="external">outline, W3C</a><br>2.<a href="https://www.deque.com/blog/give-site-focus-tips-designing-usable-focus-indicators/" target="_blank" rel="external">to design useful and usable focus indicators</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#syntax&quot;&gt;syntax&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ou
      
    
    </summary>
    
      <category term="CSS" scheme="http://www.bruceyj.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.bruceyj.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>详细理解CSS的 box-shadow</title>
    <link href="http://www.bruceyj.com/2018/10/10/2018-10-10-CSS-box-shadow/"/>
    <id>http://www.bruceyj.com/2018/10/10/2018-10-10-CSS-box-shadow/</id>
    <published>2018-10-10T21:23:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#introduction">introduction</a><ul><li><a href="#jian-rong-xing">兼容性</a></li></ul></li><li><a href="#jian-dan-de-yu-fa">简单的语法</a><ul><li><a href="#shadow-shape-spread-and-blurring-shadow-edges">shadow shape, spread, and blurring shadow edges</a></li></ul></li><li><a href="#ying-yong">应用</a></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --></div><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>本篇主要是对<code>box-shadow</code>属性的一个简单了解。主要参考资料是<a href="https://www.w3.org/TR/2017/CR-css-backgrounds-3-20171017/" target="_blank" rel="external">CSS Backgrounds and Borders Module Level 3</a>,目前最新版本是CR-css-backgrounds-3-20171017版本，虽然是比较稳定的，但是仍然会有被deprecated的可能。</p><h3><span id="jian-rong-xing">兼容性</span><a href="#jian-rong-xing" class="header-anchor">#</a></h3><p>从caniuse搜索<code>box-shadow</code>得到的结果可以看出来，所有主流浏览器都支持<code>box-shadow</code>属性(PC and Mobile),并且IE9向上同样支持。因此，我们使用该属性来实现我们想要的功能是非常安全的。</p><h2><span id="jian-dan-de-yu-fa">简单的语法</span><a href="#jian-dan-de-yu-fa" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Name: box-shadow</div><div class="line">Value:  none | &lt;shadow&gt;#</div><div class="line">Initial:  none</div><div class="line">Applies to: all elements</div><div class="line">Inherited:  no</div><div class="line">Percentages:  N/A</div><div class="line">Media:  visual</div><div class="line">Computed value: any &lt;length&gt; made absolute; any specified color computed; otherwise as specified</div><div class="line">Animatable: as shadow list</div></pre></td></tr></table></figure><p>上面是<code>box-shadow</code>的一些基本构成属性。<br>从文档可以得知，<code>box-shadow</code> 属性主要实现的效果是attaches one or more drop-shadows to the box，也就是给css box添加阴影效果。</p><p><strong>note</strong>：该property支持a comma-separated list of shadows(顺序是从front to back),简单语法表示就是<code>box-shadow: none |&lt;shadow&gt;#</code></p><p>下面是单一的shadow的正则：<br><code>&lt;shadow&gt; = inset? &amp;&amp;&lt;length&gt;{2,4}&amp;&amp;color?</code><br>上面的正则表示为如果我们要使用<code>box-shadow</code>属性：需要2 - 4 length values、 一个可选的color值、一个可选的inset关键字（省略的length值默认为0，省略的color值默认为<code>currentColor</code>）。 </p><ul><li>1st <code>&lt;length&gt;</code>(必选): the horizontal offset of the shadow. 正值表示相对于box向右偏移；负值表示相对于box向左偏移</li><li>2st <code>&lt;length&gt;</code>(必选): the vertical offset of the shadow. 正值表示相对于box向下偏移；负值表示相对于box向上偏移</li><li>3st <code>&lt;length&gt;</code>(可选): 表示blur radius（模糊半径）.负值是不允许的。blur value默认为0(这时shadow的边缘是锋利的，相当于没有模糊)。</li><li>4st <code>&lt;length&gt;</code>(可选):表示 spread distance。 取正值时，阴影扩大；取负值时，阴影收缩。默认为0，此时阴影与元素box一样大。</li></ul><p>下面来两个实际图片理解一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">width: 100px; height: 100px;</div><div class="line">border: 12px solid blue; </div><div class="line">background-color: orange;</div><div class="line">border-top-left-radius: 60px 90px;</div><div class="line">border-bottom-right-radius: 60px 90px;</div><div class="line">box-shadow: 64px 64px 12px 40px rgba(0,0,0,0.4),</div><div class="line">                     12px 12px 0px 8px rgba(0,0,0,0.4) inset;</div></pre></td></tr></table></figure></p><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181010-box-shadow-demo-1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">width: 150px;</div><div class="line">height: 150px;</div><div class="line">background-color: #fff;</div><div class="line">box-shadow: 120px 80px 40px 20px #0ff;</div><div class="line">/* 顺序为: offset-x, offset-y, blur-size, spread-size, color */</div><div class="line">/* blur-size 和 spread-size 是可选的 (默认为 0) */</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181010-box-shadow-demo-2.png" alt=""></p><h3><span id="shadow-shape-spread-and-blurring-shadow-edges">shadow shape, spread, and blurring shadow edges</span><a href="#shadow-shape-spread-and-blurring-shadow-edges" class="header-anchor">#</a></h3><p>从上面来看，我们基本了解了如何来使用<code>box-shadow</code>。但是一些具体的使用细节仍然是模糊的。<br>比如：</p><ul><li>阴影的形状是怎样的？</li><li>spread value是如何影响阴影的？和<code>inset</code>关键字的关系是怎样的？</li><li>blur radius是如何表现的？实际的、准确的效果是怎样的？</li></ul><p>我们根据<code>inset</code>关键字分两种情况来考虑:<code>outer box-shadow</code>和<code>inner box-shadow</code><br>首先来看shadow shape:</p><ol><li><code>outer box-shadow</code>: 假设spread distance为0. outer box-shadow的形状完美覆盖元素的border box.</li><li><code>inner box-shadow</code> 同样假设spread distance为0.inner box-shadow的形状完美覆盖元素的padding box.</li></ol><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/181010-box-shadow-demo-3.png" alt="基本使用"></p><p><strong>note</strong>：在上面的图片中我们可以看出,当spread value不为0时，box shadow会有相对应的扩大或收缩(不管是不是inset)。这个时候，我们希望box的形状仍然有同样的视觉效果(尤其是存在 border radius的时候)，css 规范规定了如何对corner radii进行增加或减少，来达到视觉上的效果。</p><p>下面主要讲讲<code>blur radius</code>这个属性。<br>当<code>blur radius</code>的值非0时表示shadow需要被模糊。css规范并没有规定具体的实现算法(通常都是Gaussian filter算法)，但是要求shadow达到的效果必须是合理的。<br>具体表现在视觉效果上：blur radius会创建一个明显的color transition(长度几乎是blur radius的两倍，中心点就是shadow的边缘) 。而具体的颜色变化是从shadow的内部endpoint(full shadow color)到shadow的外部endpoint（almost transparent）。</p><h2><span id="ying-yong">应用</span><a href="#ying-yong" class="header-anchor">#</a></h2><ol><li>常见的立体阴影效果。但是并没有filter的drop-shadow效果更佳逼真</li><li>模拟多重边框。<a href="https://codepen.io/lonekorean/pen/EdCjk" target="_blank" rel="external">demo</a></li></ol><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><p>1.<a href="https://drafts.csswg.org/css-backgrounds-3/#shadow-blur" target="_blank" rel="external">w3c, box-shadow</a><br>2.<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow#%3Cblur-radius%3E" target="_blank" rel="external">MDN, box-shadow</a><br>3.<a href="http://www.css88.com/archives/9360" target="_blank" rel="external">box-shadow</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jian-rong-xing&quot;&gt;兼容性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
      
    
    </summary>
    
      <category term="CSS" scheme="http://www.bruceyj.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.bruceyj.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ES6基础 - destructing</title>
    <link href="http://www.bruceyj.com/2018/08/04/2018-8-4-es6-destructing/"/>
    <id>http://www.bruceyj.com/2018/08/04/2018-8-4-es6-destructing/</id>
    <published>2018-08-04T21:23:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#introduction">introduction</a></li><li><a href="#shu-zu-de-jie-gou-fu-zhi">数组的解构赋值</a><ul><li><a href="#mo-ren-zhi">默认值</a></li></ul></li><li><a href="#dui-xiang-de-jie-gou-fu-zhi">对象的解构赋值</a></li><li><a href="#zi-fu-chuan-de-jie-gou-fu-zhi">字符串的解构赋值</a></li><li><a href="#shu-zhi-he-bu-er-zhi-de-jie-gou-fu-zhi">数值和布尔值的解构赋值</a></li><li><a href="#han-shu-de-can-shu-de-jie-gou-fu-zhi">函数的参数的解构赋值</a></li><li><a href="#yuan-gua-hao-wen-ti">圆括号问题</a><ul><li><a href="#ju-ti-de-ji-chong-qing-kuang">具体的几种情况</a></li></ul></li><li><a href="#jie-gou-de-shi-ji-kai-fa-yong-tu">解构的实际开发用途</a></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --></div><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>本文主要为ES6当中的destructing的基础知识，简单但是实用。</p><p>ES6允许我们按照一定的模式从数组和对象当中提取值，对变量进行复制，这个过程被称为destructing(解构)。<br>而在javascript当中，解构主要用于下面几种情况：</p><ul><li>数组的解构赋值</li><li>对象的解构赋值</li><li>字符串的解构赋值</li><li>数值和布尔值的解构赋值</li><li>函数参数的解构赋值</li></ul><p>以前我们给几个变量赋值:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</div><div class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</div></pre></td></tr></table></figure></p><p>而在ES6允许下面这种写法:<br><code>let [a, b, c] = [1, 2, 3];</code></p><p>上面的代码就是数组的解构赋值，本质上讲，这种写法叫做“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p><h2><span id="shu-zu-de-jie-gou-fu-zhi">数组的解构赋值</span><a href="#shu-zu-de-jie-gou-fu-zhi" class="header-anchor">#</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line">foo <span class="comment">// 1</span></div><div class="line">bar <span class="comment">// 2</span></div><div class="line">baz <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</div><div class="line">third <span class="comment">// "c"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ..tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">"a"</span>];</div><div class="line">x <span class="comment">// "a"</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// []</span></div></pre></td></tr></table></figure><p>了解了正常情况下的解构，我们了解几种正常边界之外的情况：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>]</div><div class="line">bar <span class="comment">// 1</span></div><div class="line">foo <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p><p>这种情况等号左边需要赋值的变量多于右边的值，这种情况并不会报语法错误，多余的变量会被赋予undefined。</p><p>另外一种情况：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">//4</span></div></pre></td></tr></table></figure></p><p>这种情况属于不完全解构，左边的所有变量都有值。</p><p><strong>注意</strong>： 只要某种数据结构具有Iterator接口，就可以采用数组的形式解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line">  white(<span class="literal">true</span>) &#123;</div><div class="line">   <span class="keyword">yield</span> a;</div><div class="line">   [a, b] = [b, a + b];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</div><div class="line">sixth <span class="comment">// 5</span></div></pre></td></tr></table></figure></p><h3><span id="mo-ren-zhi">默认值</span><a href="#mo-ren-zhi" class="header-anchor">#</a></h3><p>destructing允许指定默认值，但是需要注意的是，只有当一个数组成员严格等于(<code>===</code>)undefined时，默认值才会生效<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>]</div><div class="line">x <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]</div><div class="line">x <span class="comment">// null</span></div></pre></td></tr></table></figure></p><p>更加复杂一点：默认值可能是一个表达式，那么该表达式是惰性求值的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>]; <span class="comment">// 这里f函数不会执行</span></div></pre></td></tr></table></figure></p><p>默认值可以引用解构赋值的其他变量，但是前提是该变量已经声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];  <span class="comment">// x = 1; y =1;</span></div><div class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = []; <span class="comment">// ReferenceError: y is not defined.</span></div></pre></td></tr></table></figure></p><h2><span id="dui-xiang-de-jie-gou-fu-zhi">对象的解构赋值</span><a href="#dui-xiang-de-jie-gou-fu-zhi" class="header-anchor">#</a></h2><p>数组的元素是有顺序的，而对象本身是没有顺序的。这也是对象的解构不同的地方，变量必须与属性同名，才能够取到值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;foo, baz&#125; = &#123;<span class="attr">foo</span>: <span class="string">'a'</span>, <span class="attr">bar</span>: <span class="string">'b'</span>&#125;</div><div class="line">foo <span class="comment">// 'a'</span></div><div class="line">baz <span class="comment">/// undefined</span></div></pre></td></tr></table></figure></p><p>但是有时候，我们要变量名和属性名不一样该怎么写？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: baz&#125; = &#123;<span class="attr">foo</span>: <span class="string">'a'</span>&#125;</div><div class="line">baz <span class="comment">// 'a'</span></div></pre></td></tr></table></figure></p><p>也就是说，对象的destructing是先找到同名的属性，然后再赋给对应的变量。真正被赋值的是后者。<br>上面代码的foo是模式，而baz是变量。</p><p><strong>实际情况当中，我们的解构会比较的复杂，比如讲对象和数组结合</strong></p><p>另外，对象的解构也可以制定默认值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;</div><div class="line">x <span class="comment">// 3</span></div></pre></td></tr></table></figure></p><p>和数组相同的是，对象解构默认值生效的条件同样是属性值严格等于<code>undefined</code>.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;</div><div class="line">x <span class="comment">// 3</span></div></pre></td></tr></table></figure></p><p>下面来看一看边界值之外的情况：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Uncaught TypeError: Cannot destructure property `bar` of 'undefined' or 'null'.</span></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;</div></pre></td></tr></table></figure></p><p>这是由于<code>foo = undefined</code>现在，取undefined的子属性坑定会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;</div><div class="line">&#123;x&#125; = &#123;<span class="attr">x</span> : <span class="number">1</span>&#125;;</div></pre></td></tr></table></figure><p>很明显，这里<code>{x}</code>会出现二义性，js引擎会把<code>{x}</code>读成代码块，所以会报<code>syntax error</code><br>那么该如何修改呢？<code>({x} = {x:1};)</code>就可以了。</p><h2><span id="zi-fu-chuan-de-jie-gou-fu-zhi">字符串的解构赋值</span><a href="#zi-fu-chuan-de-jie-gou-fu-zhi" class="header-anchor">#</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a,b,c] = <span class="string">'hello'</span>;</div><div class="line">a <span class="comment">// 'h'</span></div><div class="line">b <span class="comment">// 'e'</span></div></pre></td></tr></table></figure><p>这里可以解构是因为字符串被转化为类似数组的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len <span class="comment">// 5</span></div></pre></td></tr></table></figure><p>类似数组的对象都会有一个<code>length</code>属性。</p><h2><span id="shu-zhi-he-bu-er-zhi-de-jie-gou-fu-zhi">数值和布尔值的解构赋值</span><a href="#shu-zhi-he-bu-er-zhi-de-jie-gou-fu-zhi" class="header-anchor">#</a></h2><p>解构赋值的规则是，只要等号右边的值不是数组或对象，就会先将其转为对象。但是由于<code>undefined</code>和<code>null</code>无法转为对象，所以对齐赋值解构会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure></p><h2><span id="han-shu-de-can-shu-de-jie-gou-fu-zhi">函数的参数的解构赋值</span><a href="#han-shu-de-can-shu-de-jie-gou-fu-zhi" class="header-anchor">#</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></div></pre></td></tr></table></figure><p>函数参数的解构也可以是使用默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span> (<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></div><div class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></div><div class="line">move(); <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure></p><p>但是，下面这种写法会出现不一样的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></div><div class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></div><div class="line">move(); <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure></p><p><code>undefined</code>就会触发函数参数的默认值。</p><h2><span id="yuan-gua-hao-wen-ti">圆括号问题</span><a href="#yuan-gua-hao-wen-ti" class="header-anchor">#</a></h2><p>解构赋值用起来会很方便，但是解析起来并不容易。对于编译器来讲，一个式子到底是模式还是表达式，是没有办法从一开始就知道的，必须等到解析到或解析不到等号才能知道。</p><p>由此，圆括号可能会带来歧义问题，ES6表示只要可能导致解构的歧义就不能使用圆括号。</p><p>因此，建议不要在模式中防止圆括号。</p><h3><span id="ju-ti-de-ji-chong-qing-kuang">具体的几种情况</span><a href="#ju-ti-de-ji-chong-qing-kuang" class="header-anchor">#</a></h3><ol><li><p>变量声明语句不能使用<br><code>let [(a)] = [1];</code></p></li><li><p>函数参数不能使用</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"> [(z</span>)] ) </span>&#123;<span class="keyword">return</span> z;&#125;</div></pre></td></tr></table></figure><p>函数参数也属于变量声明</p><ol><li>赋值语句中的模式</li></ol><p><code>([a]) = [5];</code></p><p>那么什么时候可以使用圆括号呢？<br>只有一种情况，赋值语句的非模式部分，可以使用<br><code>[(a)] = [1]; // correct</code></p><h2><span id="jie-gou-de-shi-ji-kai-fa-yong-tu">解构的实际开发用途</span><a href="#jie-gou-de-shi-ji-kai-fa-yong-tu" class="header-anchor">#</a></h2><p>(1). 交换变量的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line">[x, y] = [y, x];</div><div class="line"></div><div class="line">x <span class="comment">// 2</span></div><div class="line">y <span class="comment">// 1</span></div></pre></td></tr></table></figure></p><p>(2). 从函数返回多个值<br>我们知道函数只能返回一个值，如果我们希望返回多个值，只能将值放在数组或对象里面返回。使用destructing，可以很容易的取出这些值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    foo: <span class="number">1</span>,</div><div class="line">    bar: <span class="number">2</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure></p><p>(3). 函数参数的定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数是一组有次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 参数是一组无次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure></p><p>(4). 快速提取JSON数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonData = &#123;</div><div class="line">  id: <span class="number">42</span>,</div><div class="line">  status: <span class="string">"OK"</span>,</div><div class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(id, status, number);</div><div class="line"><span class="comment">// 42, "OK", [867, 5309]</span></div></pre></td></tr></table></figure></p><p>(5). 函数参数的默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></div><div class="line"><span class="function"><span class="params">  async = true,</span></span></div><div class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</div><div class="line">  cache = <span class="literal">true</span>,</div><div class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  crossDomain = <span class="literal">false</span>,</div><div class="line">  global = <span class="literal">true</span>,</div><div class="line">  <span class="comment">// ... more config</span></div><div class="line">&#125; = &#123;&#125;) &#123;</div><div class="line">  <span class="comment">// ... do stuff</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>和在函数体内部写<code>var foo = config.foo || &#39;default foo&#39;;</code>各有利弊。</p><p>(6). 遍历Map解构<br>可以很方便的获取键名和键值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">"is"</span> + value); </div><div class="line">&#125; </div><div class="line"><span class="comment">// first is hello</span></div></pre></td></tr></table></figure></p><p>(7). 输入模块的指定方法<br>这个是模块化开发经常用到的加载方法</p><p><code>cosnt {SourceNode} = require(&#39;source-map&#39;);</code></p><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><p>1.<a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="external">es6 destructing</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#shu-zu-de-jie-gou-fu-zhi&quot;&gt;数组的解构赋值&lt;/a&gt;&lt;u
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.bruceyj.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://www.bruceyj.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>试试讲明白pseudo-classes和pseudo-elements</title>
    <link href="http://www.bruceyj.com/2018/05/23/2018-5-23-pseudo-classes-and-pseudo-elements/"/>
    <id>http://www.bruceyj.com/2018/05/23/2018-5-23-pseudo-classes-and-pseudo-elements/</id>
    <published>2018-05-23T22:25:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#introduction">introduction</a></li><li><a href="#pseudo-classes">pseudo classes</a><ul><li><a href="#dynamic-pseudo-classes">dynamic pseudo-classes</a></li><li><a href="#the-target-pseudo-class">the target pseudo-class</a></li><li><a href="#structural-pseudo-classes">structural pseudo-classes</a></li><li><a href="#ui-element-states-pseudo-class">UI element states pseudo-class</a></li></ul></li><li><a href="#pseudo-elements">pseudo-elements</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --><p></div></p><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>最近在看基础，发现对伪类和伪元素的概念并不理解的透彻，而普通百度的文章都是写者自己的理解，因此觉得还不如直接阅读文档规范来的准确，下面就是今天的所得。</p><p>本文档主要用来解决下面几个问题：</p><ol><li>什么是pseudo classes 和 pseudo elements?</li><li>pseudo classes 和pseudo elements 两者的差别是什么？</li><li>两者的实际应用是什么？开发中我们需要注意些什么？</li></ol><h2><span id="pseudo-classes">pseudo classes</span><a href="#pseudo-classes" class="header-anchor">#</a></h2><p>首先来看下w3c规范(CSS3)里面的定义：</p><blockquote><p>The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other simple selectors.</p></blockquote><p>w3c文档中说明了pseudo class的概念被引入的理由：用于选择不存在于DOM树当中的信息或者那些不能够通过常规选择器得到的信息。</p><ol><li>不存在于DOM树当中的信息，比如<code>:active</code> or <code>:visited</code>， 用于标书link的当前状态。</li><li>不能够通过常规选择器获取的信息。比如<code>:first-child</code> or <code>nth-child()</code>等包含一些逻辑条件的选择器。</li></ol><blockquote><p>A pseudo-class always consists of a “colon” (:) followed by the name of the pseudo-class and optionally by a value between parentheses.</p></blockquote><p>这句话描述了pseudo class的基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">selector:pseudo-class &#123;</div><div class="line">    property: value;</div><div class="line">&#125;</div><div class="line">selector:pseudo-class() &#123;</div><div class="line">   property: value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>Pseudo-classes are allowed in all sequences of simple selectors contained in a selector. Pseudo-classes are allowed anywhere in sequences of simple selectors, after the leading type selector or universal selector (possibly omitted). Pseudo-class names are case-insensitive. Some pseudo-classes are mutually exclusive, while others can be applied simultaneously to the same element. Pseudo-classes may be dynamic, in the sense that an element may acquire or lose a pseudo-class while a user interacts with the document.</p></blockquote><p>这段话主要描述了pseudo-class的一些注意事项：<br>1.常规选择器可以以任何顺序使用伪类，伪类可以出现在任何位置<br>2.伪类是不区分大小写的<br>3.某些伪类是相互排斥的，而某些又是可以同时作用于同一个元素的、<br>4.伪类可能是动态的，比如用户在和document交互时元素会获得或失去一个伪类</p><p><strong>下面主要描述常用的pseudo classes</strong>:</p><h3><span id="dynamic-pseudo-classes">dynamic pseudo-classes</span><a href="#dynamic-pseudo-classes" class="header-anchor">#</a></h3><blockquote><p>Dynamic pseudo-classes classify elements on characteristics other than their name, attributes, or content, in principle characteristics that cannot be deduced from the document tree.</p></blockquote><p>规范中对于dynamic pseudo-classes的意义有了很好的描述：更多的看中元素的特性而不是他们的name这类的值。</p><p>dynamic pseudo-classes主要分为两类：</p><ol><li><code>:link</code>和<code>:visited</code></li><li><code>:hover</code> ，<code>:active</code> 和<code>:focus</code></li></ol><p>具体各个伪类的含义可以看<a href="https://www.w3.org/TR/selectors-3/#dynamic-pseudos" target="_blank" rel="external">规范</a></p><h3><span id="the-target-pseudo-class">the target pseudo-class</span><a href="#the-target-pseudo-class" class="header-anchor">#</a></h3><p><code>:target</code>用于匹配文档(页面)的URI中某个标志符的目标元素。</p><h3><span id="structural-pseudo-classes">structural pseudo-classes</span><a href="#structural-pseudo-classes" class="header-anchor">#</a></h3><p>常用的比如：</p><ol><li><code>:nth-child(an+b)</code></li><li><code>:nth-last-child(an+b)</code></li><li><code>nth-of-type(an+b)</code></li><li><code>:first-child</code></li><li><code>:last-child</code></li><li><code>:empty</code><br>这些伪类在实际开发中都会起到非常好的效果。具体使用方法看<a href="https://www.w3.org/TR/selectors-3/#structural-pseudos" target="_blank" rel="external">规范</a></li></ol><h3><span id="ui-element-states-pseudo-class">UI element states pseudo-class</span><a href="#ui-element-states-pseudo-class" class="header-anchor">#</a></h3><p>这类pseudo classes主要展现UI元素的状态，常用的包括<code>:checked</code>、<code>:disabled</code>、<code>enabled</code>.</p><h2><span id="pseudo-elements">pseudo-elements</span><a href="#pseudo-elements" class="header-anchor">#</a></h2><blockquote><p>Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document (e.g., the ::before and ::after pseudo-elements give access to generated content).</p></blockquote><p>pseudo-elements创建了抽象，这些抽象不存在于文档语言中。举例来说：</p><ol><li>文档语言没有提供机制来访问一个元素内容的第一行或第一个字符。pseudo-elements允许开发者来访问到这些信息</li><li>pseudo-elements也提供一种方式来使开发者获取到不存在源文档中的内容，比如常用的<code>::before</code>和<code>::after</code>.</li></ol><p>这段话说明了pseudo classes和pseudo elements之间的差别。伪元素创建了抽象的容器，这个容器不包含任何DOM元素，但是可以包含内容。并且我们也可以给伪元素添加样式(这也是我们为什么要叫其element)。<br>比如<code>::first-line</code>: 获取第一行内容并将其加入到抽象容器中。<br>比如<code>::before</code>和<code>::after</code>。</p><blockquote><p>A pseudo-element is made of two colons (::) followed by the name of the pseudo-element.<br>This :: notation is introduced by the current document in order to establish a discrimination between pseudo-classes and pseudo-elements. For compatibility with existing style sheets, user agents must also accept the previous one-colon notation for pseudo-elements introduced in CSS levels 1 and 2 (namely, :first-line, :first-letter, :before and :after). This compatibility is not allowed for the new pseudo-elements introduced in this specification.</p></blockquote><p>伪元素以<code>::</code>开头来区分伪类和伪元素。但是需要注意的是，考虑到兼容性，CSS1和CSS2当中的已存在的伪元素仍然可以使用<code>:</code>单冒号的方式。</p><blockquote><p>Only one pseudo-element may appear per selector, and if present it must appear after the sequence of simple selectors that represents the subjects of the selector. Note: A future version of this specification may allow multiple pseudo-elements per selector.</p></blockquote><p>这段话描述了注意事项：<br>一个选择器只能使用一个伪元素，并且伪元素位于选择器的最后(目前的的规范)。</p><h2><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h2><ol><li>pseudo classes引入的目的主要是为了弥补常规选择器的不足，以便于获取更多的关于元素的信息。而pseudo elements本质上创建了一个可以存放内容的抽象容器。</li><li>CSS3中伪类和伪元素的语法不同</li><li>伪类和伪元素的使用规则不同，可以同时使用多个伪类，而伪元素在一个选择器当中只能出现一次，并且是在选择器的最后。</li></ol><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><ol><li><a href="https://www.w3.org/TR/selectors-3/#pseudo-classes" target="_blank" rel="external">w3c document - pseudo class </a></li><li><a href="https://stackoverflow.com/questions/8069973/what-is-the-difference-between-a-pseudo-class-and-a-pseudo-element-in-css" target="_blank" rel="external">differ between pseudo classes and pseudo elements</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes" target="_blank" rel="external">MDN, pseudo classes</a></li><li><a href="https://www.cnblogs.com/ihardcoder/p/5294927.html" target="_blank" rel="external">CSS3伪类和伪元素的特性和区别</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pseudo-classes&quot;&gt;pseudo classes&lt;/a&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="CSS" scheme="http://www.bruceyj.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://www.bruceyj.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>如何更&#39;懒&#39;的用Hexo和Travis CI搭建自己的blog</title>
    <link href="http://www.bruceyj.com/2017/12/26/2017-12-26-Hexo-and-travis/"/>
    <id>http://www.bruceyj.com/2017/12/26/2017-12-26-Hexo-and-travis/</id>
    <published>2017-12-26T22:25:07.000Z</published>
    <updated>2019-05-06T07:40:25.884Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#qian-yan">前言</a></li><li><a href="#jie-jue-fang-an">解决方案</a></li><li><a href="#xiang-xi-da-jian-bu-zou">详细搭建步骤</a><ul><li><a href="#1-travis-ben-di-huan-jing-da-jian">1. travis本地环境搭建</a></li><li><a href="#2-deploy-key">2. Deploy Key</a></li><li><a href="#3-jia-mi-private-key">3. 加密 private key</a></li><li><a href="#4-she-ding-travis-yml">4. 设定 .travis.yml</a></li></ul></li><li><a href="#reference">reference</a></li></ul><!-- tocstop --><p></div></p><h2><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h2><p>社交是每个人的欲望，而单从一个技术人员角度来讲，建立自己的技术博客也是一种重要的外界沟通。blog中的每篇博文都可以是自己一段时间的技术总结(最重要的是能够有规律的坚持下去)。</p><p>Anyway!首先我们来看看一个新手在第一次尝试搭建技术博客时可能会选择的技术方案：</p><ul><li>wordpress + 云主机 + 插件(付费:目前aliyun 1核1G 330RMB/year左右,学生价120RMB/year左右，腾讯云类似)</li><li>jekyll + github pages + markdown(免费: github默认支持jekyll,可以直接将原生文件放到github上,github自动编译)</li><li>hexo + github pages + markdown(免费: 操作简单)</li></ul><p>blog本质上是静态网站(无需太多交互)，核心是文章内容，因此上面的3种方式都可以自行选择。目前我搭建的方式是第三种。<br>ok,选择好了方式，第一步肯定是在本地电脑搭建hexo。具体的搭建方式网上一大堆，这里我就不讲解如何搭建了，不过我建议直接看<a href="https://hexo.io/docs/index.html" target="_blank" rel="external">官方文档</a>即可，因为官方文档肯定是稳定最新的。</p><p><strong>另外,在这里强烈自荐我合作的<a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank" rel="external">hexo-theme-skapp</a>,欢迎star和issue</strong></p><p>前提讲完了，开始切入重点，我们在使用一段时间的hexo之后，会发现一个非常蛋疼的问题：<br><strong>每次想要更新博客，都需要到安装hexo的电脑上去更新,这真是太麻烦了…</strong><br>也就是说，最基础的跨电脑都会有困难。</p><h2><span id="jie-jue-fang-an">解决方案</span><a href="#jie-jue-fang-an" class="header-anchor">#</a></h2><p>首先，我们先来分析一下hexo:hexo本质上是一个解析markdown文件的node程序，作用在于将markdown转换成对应的HTML文件，并提供了很多实用的封装命令。</p><p>我们简单想一想，是不是可以直接版本控制来维护我们的blog程序，而github本身不就是一个版本控制的网站吗?</p><p>那么我们可以将hexo作为blog代码库的一个分支来同步到github上面(注意配置下<code>.gitignore</code>文件，ignore不需要维护的文件)。这样，一旦我们希望用另外一台电脑来更新博客，我们只需要将blog的代码库检下来即可。这样多台电脑就相当于多个开发共同开发维护blog代码库。</p><p>但是，这样用着一段时间后，仍然会存在一些小问题。<br>先举个例子：比如我有一台win10的thinkpad笔记本，还有一台macbook pro，公司里面使用的ubuntu 16.04LTS. 这3台电脑我都会维护更新我的博客。首先，这3台电脑都git clone了blog代码库。然后，我们<code>npm install</code>了node的依赖包，这个时候我们可能会发现某些系统下hexo程序运行报错(对，没错我说的就是windows,比如node最基本的node-gyp在win下安装就很麻烦)，虽然，我们可以通过各种补丁等等东西解决了系统问题，但是这个仍然非常的麻烦啊！</p><p>那能不能在多个系统的电脑上更新博客，而不需要考虑系统的兼容性问题？</p><p>下面就DuangDuangDuang的介绍下<a href="https://travis-ci.org/" target="_blank" rel="external">travis CI</a>,travis CI是一种构建和测试的自动化工具。从其简称CI就可以理解，Travis CI提供的是持续集成服务(Continuous Integration).它可以绑定github上面的项目，只要有新的代码提交，就会自动抓取，然后travis会提供一个运行环境，执行测试，完成构建并部署到服务器。</p><p>通过travis CI，我们每次只要更新markdown文件，网站内容就能自动更新了。在这里就不具体的讲如何入门travis CI了，具体学习可以点击<a href="https://docs.travis-ci.com/" target="_blank" rel="external">travis CI官网</a>或者<a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="external">阮一峰travis CI教程</a></p><h2><span id="xiang-xi-da-jian-bu-zou">详细搭建步骤</span><a href="#xiang-xi-da-jian-bu-zou" class="header-anchor">#</a></h2><p>我们在部署博客时，<code>hexo d</code>就可以搞定，但是问题在于Travis CI本身并没有对github库进行push操作的权限。如果我们直接将密钥直接放在开源库中，则相当于将代码库的提交权限开放给所有github的使用者，因此，我们需要一些加密操作。</p><h3><span id="1-travis-ben-di-huan-jing-da-jian">1. travis本地环境搭建</span><a href="#1-travis-ben-di-huan-jing-da-jian" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ruby</div></pre></td></tr></table></figure><p>首先本机安装ruby。</p><h3><span id="2-deploy-key">2. Deploy Key</span><a href="#2-deploy-key" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></div></pre></td></tr></table></figure><p>首先通过<code>ssh-keygen</code>生成一个SSH key专门提供给github中blog库使用。在生成SSH key时，将passphrase留空，因为在travis中输入密码比较麻烦。<br>然后将制作完成的Public key复制到github blog代码库的Deploy key里面，如下：</p><h3><span id="3-jia-mi-private-key">3. 加密 private key</span><a href="#3-jia-mi-private-key" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gem install travis // 安装travis命令行工具</div><div class="line">$ travis login --auto // 命令行登录travis</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ travis encrypt-file ssh_key --add</div></pre></td></tr></table></figure><p>这里假设private key的文件名为<code>ssh_key</code>,travis会加密产生<code>ssh_key.enc</code>,并自动在<code>.travis.yml</code>的<code>before_install</code>位置自动插入解密指令。<br><em>注意</em>：这里在windows系统下使用<code>travis encrypt-file</code>命令加密生成的<code>ssh_key.enc</code>在travis执行时会在解密密钥时失败。具体原因在travis的issue中可以查看<a href="https://github.com/travis-ci/travis-ci/issues/4746" target="_blank" rel="external">File decryption fails on Windows</a>.最简单的做法就是在linux或mac环境下生成该文件。</p><h3><span id="4-she-ding-travis-yml">4. 设定 .travis.yml</span><a href="#4-she-ding-travis-yml" class="header-anchor">#</a></h3><p>首先我们在blog根目录下建立<code>.travis</code>文件夹和<code>.travis.yml</code>文件。<br>然后我们将生成的<code>ssh_key.enc</code>移动到本地blog项目的<code>.travis</code>文件夹下面，并在<code>.travis</code>目录下创建<code>ssh_config</code>文件，然后配置Travis上的SSH设定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Host github.com</div><div class="line">  User git</div><div class="line">  StrictHostKeyChecking no</div><div class="line">  IdentityFile ~/.ssh/id_rsa</div><div class="line">  IdentitiesOnly yes</div></pre></td></tr></table></figure></p><p>因为我们刚刚修改了<code>ssh_key.enc</code>的位置，因此我们需要修改<code>.travis.yml</code>中刚刚插入的解密指令(不要照抄，不同的环境修改不一样)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- openssl aes-256-cbc -K <span class="variable">$encrypted_06b8e90ac19b_key</span> -iv <span class="variable">$encrypted_06b8e90ac19b_iv</span> -<span class="keyword">in</span> .travis/ssh_key.enc -out ~/.ssh/id_rsa -d</div></pre></td></tr></table></figure></p><p>该命令会利用openssl来解密private key,并将解密后的文件放在 <code>~/.ssh/id_rsa</code>，接着我们指定该档案的权限:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- chmod 600 ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p><p>然后将private key加入到系统中:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- <span class="built_in">eval</span> $(ssh-agent)</div><div class="line">- ssh-add ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p><p>接下来将<code>ssh_config</code>文件复制到<code>~/.ssh</code>目录下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- cp .travis/ssh_config ~/.ssh/config</div></pre></td></tr></table></figure></p><p>为了使git操作能够正常进行，我们需要事先设定git的使用者讯息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- git config --global user.name <span class="string">"Bruce"</span></div><div class="line">- git config --global user.email <span class="string">"your email address"</span></div></pre></td></tr></table></figure></p><p>最后的结果大概如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="attr">language:</span> <span class="string">node_js</span></div><div class="line"><span class="attr">node_js:</span> <span class="string">stable</span></div><div class="line"><span class="attr">cache:</span></div><div class="line"><span class="attr">  directories:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">node_modules</span></div><div class="line"><span class="attr">before_install:</span></div><div class="line">  <span class="comment"># Decrypt the private key</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_0c8703cca11f_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_0c8703cca11f_iv</span> <span class="bullet">-in</span> <span class="string">.travis/id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div><div class="line">  <span class="comment"># Set the permission of the key</span></div><div class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line">  <span class="comment"># Start SSH agent</span></div><div class="line"><span class="bullet">  -</span> <span class="string">eval</span> <span class="string">$(ssh-agent)</span></div><div class="line">  <span class="comment"># Add the private key to the system</span></div><div class="line"><span class="bullet">  -</span> <span class="string">ssh-add</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line">  <span class="comment"># Copy SSH config</span></div><div class="line"><span class="bullet">  -</span> <span class="string">cp</span> <span class="string">.travis/ssh_config</span> <span class="string">~/.ssh/config</span></div><div class="line">  <span class="comment"># Set Git config</span></div><div class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.name</span> <span class="string">"Bruce"</span></div><div class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.email</span> <span class="string">"444048170@qq.com"</span></div><div class="line"><span class="attr">install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">g</span></div><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">deploy</span></div><div class="line"><span class="attr">branches:</span></div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">hexo</span></div></pre></td></tr></table></figure></p><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><p>1.<a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="external">tommy351,continuous-deployment-to-github-with-travis</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#qian-yan&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jie-jue-fang-an&quot;&gt;解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#xiang-xi
      
    
    </summary>
    
      <category term="博客" scheme="http://www.bruceyj.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://www.bruceyj.com/tags/Hexo/"/>
    
      <category term="Travis CI" scheme="http://www.bruceyj.com/tags/Travis-CI/"/>
    
      <category term="Blog" scheme="http://www.bruceyj.com/tags/Blog/"/>
    
  </entry>
  
</feed>
