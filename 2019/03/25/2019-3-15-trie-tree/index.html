<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>算法之trie tree | BruceYJ BLOG</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="bruceYJ blog, 前端博客, 前端, 程序员, 前端开发, 全栈开发, node.js, javascript, python, 心理学, 人工智能"><meta name="description" content="该博客用来分享平时有意思的技术所得与各种思考"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://www.bruceyj.com/2019/03/25/2019-3-15-trie-tree/index.html"><link rel="icon" type="image/png" href="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/config/yu.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="BruceYJ"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/config/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="BruceYJ" alt="BruceYJ"><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/config/logo_1.png" alt="BruceYJ"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/tags" alt="标签" title="标签">标签</a></li><li class="nav__item"><a href="/demo" alt="作品" title="作品">作品</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree.png" alt="算法之trie tree"></div><header class="post__info"><h1 class="post__title">算法之trie tree</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/BruceYuj">BruceYJ</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2019-03-25</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Algorithm/">Algorithm</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><div class="toc"><ul><li><a href="#introduction">introduction</a></li><li><a href="#trie-tree">Trie tree</a><ul><li><a href="#ji-ben-cao-zuo">基本操作</a></li><li><a href="#shi-ji-ying-yong">实际应用</a></li></ul></li><li><a href="#reference">reference</a></li></ul></div><hr><h2><span id="introduction">introduction</span><a href="#introduction" class="header-anchor">#</a></h2><p>最近在做ASTR，而algorithm是该项目的task 1. 所以开始重新刷LeetCode题。相比其他ACM题库而言，LeetCode的难度属于初、中级，更加的偏向于职场，而弱化了一些高级数学相关的东西。</p><p>这段话是我对于刷LeetCode的一些看法。很多人觉得算法对于实际工作过程中的用途不大，有点类似于“面试造火箭，工作拧螺丝”。但是真的用途不大吗？我觉得并非如此，如果你能够发现里面的数学之美的话。其一，一个优秀的算法可以极大的提高你的程序运行效率，尤其在某些极端情况下面；其二，学习了这些算法，可以极大的提高我们的逻辑思维；其三，这对于面试还是有很多好处的。</p><p>我做LeetCode的方法是：</p><ol><li>选取某一到特定的题目（一般是净点赞多的优先）</li><li>做题，并研究其抽象出来的原理</li><li>举一反三运用于这一类题</li></ol><p><strong>Note</strong>： 特别强调，刷题不是目的，会做某一到具体的题更不是完成结果。学会每道题背后的原理，并能够理解、完成所有的这一类问题，以及将其运用于自己的工作当中，这才是我们真正需要达到的目标。</p><p>举个例子：</p><ol><li>选取题目leetcode 5: Longest Palindromic Substring</li><li>由该题目联想到经典的两类问题： longest common substring problem 和 longest common subsequence problem。然后，联系到longest common substring problem的一般解决思路，generalized suffix tree，在细化到 trie tree。</li><li>搜索相关的问题，并解决。</li></ol><h2><span id="trie-tree">Trie tree</span><a href="#trie-tree" class="header-anchor">#</a></h2><p>首先<em>Trie</em> 来自于单词<em>retrieval</em>, 通常发音为 /ˈtraɪ/ (as “try”).</p><blockquote><p>In computer science, a trie, also called digital tree, radix tree or prefix tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings.</p></blockquote><p>Trie tree，又被称为字典树或前缀树。从名字我们可以推断出其可以被用来查找字符串。</p><p>我们先来看一个例子：</p><ol><li>给定一个字符串集合<code>cat, cash, app, apple , aply, ok</code>，来构建一颗字典树， 如下图：</li></ol><p><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-1.jpg" alt="Trie tree 1"></p><p>由此我们引出字典树的特点：</p><ol><li>Trie tree用边来表示字母</li><li>有相同前缀的单词公用前缀节点。那么我们可以知道，在单词只包含小写字母的情况下，我们可以知道每个节点最多有26个子节点</li><li>整棵树的根节点是空的</li><li>每个单词结束的时候用特殊字符表示(比如上图的$)，在代码中可以单独建立一个bool字段来表示是否是单词结束处</li></ol><h3><span id="ji-ben-cao-zuo">基本操作</span><a href="#ji-ben-cao-zuo" class="header-anchor">#</a></h3><p>最简单的两个操作为: <strong>insert</strong> 和 <strong>search</strong></p><ol><li>insert: 插入一个新单词<blockquote><p>从图中可以直观看出来，从左到右扫描新单词，如果字母在相应根节点下没有出现过，就插入这个字母；否则沿着字典树往下走，看单词的下一个字母。</p></blockquote></li></ol><p>问题1： 字母往哪个位置插？<br>有两种编码方式。第一种可以按照输入顺序对其进行编码，这里相同字母的编码可能不同：<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-2.jpg" alt="trie tree 2"></p><p>第二种编码方式:<br>因为每个节点最多26个子节点，我可以可以按他们的字典序0-25编号，这里相同字母的编码相同<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-3.jpg" alt="enter description here"></p><p>通常来讲，我们来实现这个数据结构会有两种方式：</p><ul><li>数组模拟</li><li>类的形式</li></ul><p>通常，虽然第二种方式更加的浪费空间，但是我会更加的喜欢用第二种方式。比如在处理下面这几个问题时更加方便：</p><ul><li>查询某个单词是否存在字典树中。我们只需要在节点中添加属性表示即可。</li><li>查询某个前缀出现的次数。我们仍然只需要在节点中添加属性即可。</li></ul><p>因此，我们来看实际的代码(javascript版):<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">var</span> TrieNode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.isEnd = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">this</span>.links = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>);</div><div class="line">&#125;</div><div class="line">TrieNode.prototype.containsKey = <span class="function"><span class="keyword">function</span>(<span class="params">ch</span>) </span>&#123; <span class="comment">// 当前节点的子节点中是否包含该字符</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.links[ch.charCodeAt(<span class="number">0</span>) - <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>)] !== <span class="literal">undefined</span>; </div><div class="line">&#125;</div><div class="line">TrieNode.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">ch</span>) </span>&#123; <span class="comment">// 获取当前节点相关字符的子节点</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.links[ch.charCodeAt(<span class="number">0</span>) - <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>)];</div><div class="line">&#125;</div><div class="line">TrieNode.prototype.put = <span class="function"><span class="keyword">function</span>(<span class="params">ch, node</span>) </span>&#123; <span class="comment">// 插入当前相关字符的子节点</span></div><div class="line">    <span class="keyword">this</span>.links[ch.charCodeAt(<span class="number">0</span>) - <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>)] = node;</div><div class="line">&#125;</div><div class="line">TrieNode.prototype.setEnd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 设置当前节点是否为单词结尾</span></div><div class="line">    <span class="keyword">this</span>.isEnd =<span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Initialize your data structure here.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> Trie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Inserts a word into the trie. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; word</span></div><div class="line"><span class="comment"> * @return &#123;void&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> currentChar = word[i];</div><div class="line">        <span class="keyword">if</span>(!node.containsKey(currentChar)) &#123;</div><div class="line">            node.put(currentChar, <span class="keyword">new</span> TrieNode());</div><div class="line">        &#125;</div><div class="line">        node = node.get(currentChar);</div><div class="line">    &#125;</div><div class="line">    node.setEnd();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns if the word is in the trie. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; word</span></div><div class="line"><span class="comment"> * @return &#123;boolean&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> currentChar = word[i];</div><div class="line">        <span class="keyword">if</span>(node.containsKey(currentChar)) &#123;</div><div class="line">            node = node.get(currentChar);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node.isEnd();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns if there is any word in the trie that starts with the given prefix. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; prefix</span></div><div class="line"><span class="comment"> * @return &#123;boolean&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> currentChar = word[i];</div><div class="line">        <span class="keyword">if</span>(node.containsKey(currentChar)) &#123;</div><div class="line">            node = node.get(currentChar);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> */</span></div><div class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> Trie();</div><div class="line">  <span class="keyword">let</span> words = [<span class="string">"Trie"</span>,<span class="string">"insert"</span>,<span class="string">"search"</span>,<span class="string">"search"</span>,<span class="string">"startsWith"</span>,<span class="string">"insert"</span>,<span class="string">"search"</span>]</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; words.length; i++ ) &#123;</div><div class="line">    obj.insert(words[i]);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p></p><p>很明显，上面的写法比较偏向于工程化，比较完整类型的，上面的代码可以更加的优化,我们用对象来模拟：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Trie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">this</span>.root = &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Inserts a word into the trie. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; word</span></div><div class="line"><span class="comment"> * @return &#123;void&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> word) &#123;</div><div class="line">      <span class="keyword">if</span> (!(ch <span class="keyword">in</span> node)) node[ch] = &#123;&#125;</div><div class="line">      node = node[ch]</div><div class="line">    &#125;</div><div class="line">    node[<span class="string">'$'</span>] = <span class="literal">true</span> <span class="comment">// 表示单词结束位置</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns if the word is in the trie. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; word</span></div><div class="line"><span class="comment"> * @return &#123;boolean&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ch <span class="keyword">of</span> word) &#123;</div><div class="line">      <span class="keyword">if</span>(ch <span class="keyword">in</span> node) node = node[ch]</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> node[<span class="string">'$'</span>] === <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns if there is any word in the trie that starts with the given prefix. </span></div><div class="line"><span class="comment"> * @param &#123;string&#125; prefix</span></div><div class="line"><span class="comment"> * @return &#123;boolean&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Trie.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ch <span class="keyword">of</span> prefix) &#123;</div><div class="line">      <span class="keyword">if</span>(ch <span class="keyword">in</span> node) node = node[ch]</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>我们来看看两段代码的运行效率：<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-result.png" alt="execute result"></p><h3><span id="shi-ji-ying-yong">实际应用</span><a href="#shi-ji-ying-yong" class="header-anchor">#</a></h3><p>我们下面来看看实际开发中trie tree的运用：</p><ol><li><p>autocomplete<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-208_GoogleSuggest.png" alt="enter description here"></p></li><li><p>spell checker<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-208_SpellCheck.png" alt="enter description here"></p></li><li><p>IP routing(longest prefix matching)<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-208_IPRouting.gif" alt="enter description here"></p></li><li><p>T9 predictive text<br><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree-208_T9.jpg" alt="enter description here"></p></li></ol><h2><span id="reference">reference</span><a href="#reference" class="header-anchor">#</a></h2><ol><li><a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="external">Trie, wiki</a></li><li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/submissions/" target="_blank" rel="external">leetcode 208. Implement Trie (Prefix Tree)</a></li></ol><div class="post-announce">感谢您的阅读，本文由 <a href="https://www.github.com/BruceYuj">BruceYJ</a> 原创提供。如若转载，请注明出处：BruceYJ（<a href="https://www.github.com/BruceYuj">https://www.github.com/BruceYuj</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2019/02/19/2019-2-19-deep-into-css-box-model/" title="深入CSS基础之box model"><i class="iconfont icon-prev"></i>深入CSS基础之box model</a></div><div class="post__prev post__prev--right"><a href="/2019/05/02/2019-5-2-ECMAScript-Number-type-and-IEEE-754/" title="ECMAScript中的Number Type与 IEEE 754-2008">ECMAScript中的Number Type与 IEEE 754-2008<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">该博客用来分享平时有意思的技术所得与各种思考</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/博客/">博客</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/JavaScript/">JavaScript</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Front-End/">Front End</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/ECMAScript/">ECMAScript</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Computer-Science/">Computer Science</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/CSS/">CSS</a><span class="block-list-count">5</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Algorithm/">Algorithm</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2019/05/02/2019-5-2-ECMAScript-Number-type-and-IEEE-754/" title="ECMAScript中的Number Type与 IEEE 754-2008"><div class="item__cover"><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-5-2-ECMAScript-Number-type-and-IEEE-754-head.png" alt="ECMAScript中的Number Type与 IEEE 754-2008"></div><div class="item__info"><h3 class="item__title">ECMAScript中的Number Type与 IEEE 754-2008</h3><span class="item__text">2019-05-02</span></div></a></li><li class="latest-post-item"><a href="/2019/03/25/2019-3-15-trie-tree/" title="算法之trie tree"><div class="item__cover"><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190325-trie-tree.png" alt="算法之trie tree"></div><div class="item__info"><h3 class="item__title">算法之trie tree</h3><span class="item__text">2019-03-25</span></div></a></li><li class="latest-post-item"><a href="/2019/02/19/2019-2-19-deep-into-css-box-model/" title="深入CSS基础之box model"><div class="item__cover"><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/190219-deep-into-css-box-model.png" alt="深入CSS基础之box model"></div><div class="item__info"><h3 class="item__title">深入CSS基础之box model</h3><span class="item__text">2019-02-19</span></div></a></li><li class="latest-post-item"><a href="/2019/02/13/2019-2-13-deep-into-css-assign-property-values/" title="深入CSS之属性赋值"><div class="item__cover"><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/posts/2019-2-13-deep-into-css-assign-property-values.png" alt="深入CSS之属性赋值"></div><div class="item__info"><h3 class="item__title">深入CSS之属性赋值</h3><span class="item__text">2019-02-13</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-item"><a class="tag-link" href="/tags/Blog/">Blog</a></li><li class="tag-item"><a class="tag-link" href="/tags/CSS/">CSS</a></li><li class="tag-item"><a class="tag-link" href="/tags/Computer-Science/">Computer Science</a></li><li class="tag-item"><a class="tag-link" href="/tags/ECMAScript/">ECMAScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/ES6/">ES6</a></li><li class="tag-item"><a class="tag-link" href="/tags/Front-End/">Front End</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/Travis-CI/">Travis CI</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>ShangHai</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>bruceyu1992@gmail.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="https://myblog-1257043911.cos.ap-chengdu.myqcloud.com/config/qrcode.jpg" alt="logo" title="BruceYJ"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://aotu.io/" title="aotu" target="_blank">凹凸实验室</a></li><li class="list-item"><a href="http://taobaofed.org/" target="_blank">淘宝FED</a></li><li class="list-item"><a href="http://fex.baidu.com/" target="_blank">百度FEX</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="Blog theme" target="_blank">Skap</a></li><li class="list-item"><a href="https://travis-ci.org/" title="auto deploying tool" target="_blank">Travis CI</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/BruceYuj" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:bruceyu1992@gmail.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><div id="hexo-helper-live2d"><canvas id="live2dcanvas" width="150" height="300"></canvas></div><style>#live2dcanvas{position:fixed;width:150px;height:300px;opacity:1;left:0;z-index:999;pointer-events:none;bottom:-20px}</style><script type="text/javascript" src="/live2d/device.min.js"></script><script type="text/javascript">const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/koharu.model.json", 0.5);});
})();</script><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["Algorithm"],gitalk=new Gitalk({clientID:"68028aaae7e623337529",clientSecret:"b46df86e59c34d34b92cb552b1ac94849106d60f",repo:"BruceYuj.github.io",owner:"BruceYuj",admin:["BruceYuj"],labels:tags,id:new Date(1553526787e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>